# 3장. 영속성 관리

### 엔티티 매니저 팩토리
엔티티 매니저를 생산하는 공장
- 여러 스레드가 동시에 접근해도 안전
### 엔티티 매니저
- 엔티티 매니저 팩토리에서 생성된다.
    - 엔티티 매니저를 생성하면 영속성 컨텍스트도 하나 함께 만들어진다.
- 영속성 컨텍스트를 접근할 수 있다.
>  엔티티 관리자, 엔티티 저장 가상 DB
- 여러 스레드가 동시에 접근하면 동시성 문제 발생
    - 스레드간에 절대 공유하면 안된다.
- 트랜잭션을 시작할때 커넥션을 얻는다.

### 영속성 컨텍스트
- 엔티티를 영구 저장하는 환경
- 애플리케이션과 db 사이에서 객체를 보관하는 가상의 데이터베이스
> 영속성 컨텍스트에 저장한 엔티티는 flush 시점에 db에 반영되는데, 일반적으로 트랜잭션을 커밋할때 영속성 컨텍스트가 flush 된다.

#### 특징
- 영속 컨텍스트는 엔티티를 식별자 값으로 구분하므로, 반드시 식별자 값이 있어야한다.
- 영속성 컨텍스트에 엔티티를 저장하면 트랜잭션을 커밋하는 순간 flush가 호출되며 영속 컨텍스트를 db와 동기화한다.
- 제공 기능
    - 1차 캐시
    - 동일성 보장
    - 트랜잭션을 지원하는 쓰기 지연
    - 변경 감지
    - 지연 로딩
#### 1차 캐시
- 영속성 컨텍스트 내부의 캐시
    - 엔티티 조회시 db가 아닌 메모리에서 바로 조회하여 성능상 이점이 있다.
    - 엔티티의 동일성을 보장한다. (REPEATABLE READ을 애플리케이션 차원에서 제공)
- 키는 식별자, 값은 엔티티 인스턴스
    - 엔티티를 영속화하면 2차 캐시에 엔티티 인스턴스를 저장한다.

### 엔티티 생명주기
- 비영속 : 영속성 컨텍스트와 전혀 관계가 없는 상태
- 영속: 영속성 컨텍스트에 저장된 상태, 영속성 컨텍스트가 관리하는 엔티티
- 준영속: 영속성 컨텍스트에 저장되었다가 분리된 상태
- 삭제: 영속성 컨텍스트와 db에서 삭제된 상태

#### 엔티티 조회
- 엔티티 조회시 1차 캐시에서 식별자 값으로 엔티티를 찾고, 없으면 db에서 찾아 1차 캐시에 해당 엔티티를 저장한 후 영속 상태의 엔티티를 반환한다.

#### 엔티티 등록
- 엔티티를 영속성 컨텍스트에 등록하면 1차 캐시에 해당 엔티티를 저장하면서 동시에 쓰기 지연 SQL 저장소에 INSERT SQL을 보관한다.
- 트랜잭션 commit을 호출하면, 엔티티 매니저는 영속성 컨텍스트를 flush한 후 트랜잭션을 commit한다.
    - flush : 영속성 컨텍스트의 변경 내용을 db에 동기화 = 쓰기 지연 SQL 저장소의 쿼리를 db에 전송
> 모아둔 등록 쿼리를 db에 한번에 전달함으로써 성능을 최적화한다.

#### 엔티티 수정(변경 감지)
- 스냅샷 : 엔티티를 영속성 컨텍스트에 보관할때, 최초 상태를 보관해서 저장한다.
- 트랜잭션 commit을 호출하면, 엔티티 매니저는 flush가 호출되며 엔티티와 스냅샷을 비교해서 수정 쿼리를 쓰기 지연 SQL 저장소에 보낸다.
- 쓰기 지연 저장소의 SQL을 db에 보내고 트랜잭션을 커밋한다.
> 변경 감지는 영속상태의 엔티티에만 적용된다.

- 엔티티의 모든 필드를 업데이트한다.
    - 수정 쿼리가 항상 같아서 재사용할 수 있기 때문이다.
    - 일부 필드만 업데이트하려면 `@DynamicUpdate`, 생성하려면 `@DynamicInsert`를 사용

#### 엔티티 삭제
- 삭제 대상 엔티티를 조회하고 `remove()`를 호출하면 영속성 컨텍스트에서 대상 엔티티를 제거하고, 삭제 쿼리를 쓰기 지연 SQL 저장소에 등록한 후 트랜잭션 commit 호출시 flush가 일어나면서 db에 쿼리가 보내지고 커밋된다.

### flush
- 영속성 컨텍스트의 변경 내용을 데이터베이스에 반영(동기화)
1. 변경 감지가 동작해서 영속성 컨텍스트에 있는 모든 엔티티와 스냅샷을 비교해서 수정 쿼리를 만들고 쓰기 지연 SQL 저장소에 등록한다.
2. 쿼리를 db에 전송한다.

- 호출방법
    - `em.flush()` 직접 호출(거의 사용X)
    - 트랜잭션 커밋시 flush 자동 호출
    - JPQL 쿼리 실행시 flush 자동 호출
> jqpl은 db에 직접 sql을 날리므로 그 전에 db를 영속성 컨텍스트의 내용와 동기화하기 위해서

- 옵션
    - `FlushModeType.AUTO` : 커밋하거나 쿼리 실행시 flush
    - `FlushModeType.COMMIT` : 커밋시 flush
        - 성능 최적화를 위해 사용

### 준영속
- 준영속 상태의 엔티티는 영속성 컨텍스트가 제공하는 기능을 사용할 수 없다.
    - 1차 캐시, 쓰기 지연, 변경 감지, 지연 로딩을 포함한 영속성 컨텍스트가 제공한 기능이 동작하지 않는다.
    - 식별자 값을 가지고 있다. (한번 영속상태였으므로)
    - 지연 로딩을 할 수 없다.
- 준영속 방법
    - `em.detach()` : 특정 엔티티만 준영속 상태로 전환
    - `em.clear()` : 영속성 컨텍스트 초기화
    - `em.close()` : 영속성 컨텍스트 종료

#### 병합(merge)
- 준영속 상태의 엔티티를 다시 영속 상태로 변경
- merge()는 준영속 상태의 엔티티를 받아서 그 정보로 **새로운 영속 상태의 엔티티를 반환**한다.
    - 준영속 상태의 엔티티의 식별자 값으로 1차 캐시에서 엔티티를 조회하고, 없으면 db에서 조회하여 1차 캐시에 엔티티를 저장한다.
    - 새로 생성된 영속 엔티티에 병합한 준영속 엔티티의 정보를 밀어 넣고, 영속 엔티티를 반환한다.
- save or update
    - 비영속 -> 영속, 준영속 -> 영속 모두 가능하다.
    - db에 없는 새로운 엔티티이면 새로운 엔티티를 생성해서 병합한다.

#### 기타
- 쓰기 지연: 트랜잭션 커밋 전까지 내부 쿼리 저장소에 쿼리 모아두기
- 변경 감지(dirty checking): 엔티티의 변경 사항을 데이터베이스에 자동 반영
