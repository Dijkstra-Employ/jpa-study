# 15장. 고급 주제와 성능 최적화

# 15.1 예외 처리
### JPA 표준 예외 정리
- JPA 예외는 모두 언체크 예외이다.
- **트랜잭션 롤백을 표시하는 예외**
    - 심각한 예외이므로 복구해서는 안된다.
    - 강제로 커밋해도 트랜잭션이 커밋되지 않고 `RollbackException` 예외가 발생한다.
- **트랜잭션 롤백을 표시하지 않는 예외**
    - 심각한 예외가 아니다.
    - 개발자가 커밋할지 롤백할지 선택하면 된다.

### 스프링 프레임워크의 JPA 예외 변환
- 서비스 계층에서 `JPA 예외`를 직접 사용하면 `JPA`에 의존하게 된다.
- 스프링 프레임워크는 데이터 접근 계층에 대한 예외를 추상화해서 개발자에게 제공한다.
    - `JPA 예외` -> `스프링 예외`

### 스프링 프레임워크에 JPA 예외 변환기 사용
- JPA 예외를 스프링 프레임워크가 제공하는 추상화된 예외로 변경하려면 `PersistenceExceptionTranslationPostProcessor`를 스프링 빈으로 등록하면 된다.
- `@Repository`를 사용한 곳에 `예외 변환 AOP`를 적용해서 `JPA 예외`를 `스프링 프레임워크가 추상화한 예외`로 변환해준다.
- 예외를 변환하고 싶지 않다면 `throws` 절에 그대로 반환할 JPA 예외나 JPA 예외의 부모 클래스를 직접 명시하면 된다.

### 트랜잭션 롤백시 주의사항
- 트랜잭션을 롤백하는 것은 데이터베이스의 반영 사항만 롤백하는 것이지 수정한 자바 객체까지 원상태로 복구해주지는 않는다.
    - **객체는 수정된 상태로 영속성 컨텍스트에 남아있다.**
- 따라서 롤백된 영속성 컨텍스트를 그대로 사용하는 것보다 새로운 영속성 컨텍스트를 생성해서 사용하거나,  `EntityManager.clear()`를 호출해서 영속성 컨텍스트를 초기화한 다음에 사용해야한다.

- **트랜잭션당 영속성 컨텍스트 전략** : 문제가 발생하면 트랜잭션을 롤백하면서 영속성 컨텍스트도 함께 종료하므로 문제가 발생하지 않는다.
- **OSIV**: 여러 트랜잭션이 하나의 영속성 컨텍스트를 사용하므로 롤백 후 다른 트랜잭션이 영속성 컨텍스트를 사용할 수 있는 문제가 있다.
    - **스프링 OSIV**는 `트랜잭션 롤백시 영속성 컨텍스트를 초기화`해서 잘못된 영속성 컨텍스트를 사용하는 문제를 예방한다.

# 15.2 엔티티 비교
- **1차 캐시**: 영속성 컨텍스트 내부에는 엔티티 인스턴스를 보관하기 위한 1차 캐시가 있다.
    - 1차 캐시는 영속성 컨텍스트와 생명주기가 같다.
    - 영속성 컨텍스트를 통해 데이터를 저장하거나 조회하면 1차 캐시에 엔티티가 저장된다.
    - `변경 감지`도 동작하고, 데이터베이스를 통하지 않고 데이터를 바로 조회할 수 있다.
    - **애플리케이션 수준의 반복 가능한 읽기**(항상 같은 엔티티 인스턴스 반환)을 제공한다.
        - 주소값이 같은 인스턴스를 반환한다.

### 영속성 컨텍스트가 같을 때 엔티티 비교
- 테스트 클래스에 `@Transactional`이 있으면 트랜잭션을 먼저 시작하고 테스트 메서드를 수행한다.
- 같은 트랜잭션 범위에 있으면 같은 영속성 컨텍스트를 사용하므로 동일성(`\==`), 동등성(`equals()`), 데이터베이스 동등성(`@Id`)을 모두 만족한다.

### 영속성 컨텍스트가 다를때 엔티티 비교
- 테스트에 `@Transactional`이 없고 서비스에 `@Transactional`이 있을 때
    - 서비스에서 조회한 엔티티 레포지토리에서 조회한 엔티티는 다른 영속성 컨텍스트(트랜잭션)에서 각각 조회한 엔티티이므로 서로 다른 인스턴스를 반환한다.
    - 동일성(`\==`) 비교에 실패한다.
- 다른 영속성 컨텍스트에서 조회하더라도 같은 엔티티이므로 동등성 비교에 성공해야한다.
    - `데이터베이스 동등성 비교(db 식별자)` 나 `동등성 비교(비즈니스 키)`를 통해 같게 판단하도록 하자.
        - 비즈니스 키는 보통 중복되지 않고 거의 변하지 않는 데이터베이스 기본키 후보들이 좋다.
        - db 기본키처럼 딱딱하게 정하지 않아도 되고, 가끔 변해도 괜찮다.
> 동일성 비교는 같은 영속성 컨텍스트의 관리를 받는 영속 상태의 엔티티에만 적용할 수 있다.
> 그렇지 않을 때는 `비즈니스 키`를 사용한 동등성 비교를 해야 한다.

# 15.3 프록시 심화 주제
- `프록시`는 `원본 엔티티`를 상속받아 만들어진다.
    - 이를 통해 클라이언트는 엔티티가 프록시인지 원본 엔티티인지 구분하지 않고 사용할 수 있다.

## 영속성 컨텍스트와 프록시
- 영속성 컨텍스트는 자신이 관리하는 영속 엔티티의 동일성을 보장한다.
- **프록시로 조회한 엔티티의 동일성도 보장한다.**
    - 프록시로 먼저 조회한 후 엔티티를 조회하면 `처음 조회된 프록시`를 반환한다.
    - 엔티티를 조회한 후 프록시를 조회하면 `엔티티`를 반환한다.

### 프록시 타입 비교
- 프록시와 원본 엔티티를 비교할 때는 `\==`이 아니라 `instanceof`를 사용해야 한다.
    - 프록시는 원본 엔티티를 상속받는 자식이기 때문이다.

### 프록시 동등성 비교
- 프록시 타입 비교는 `\==` 비교 대신에 `instanceof`를 사용해야 한다.
- 프록시의 멤버변수에 직접 접근하면 안되고, 대신에 접근자 메서드(`getter`)를 사용해야한다.
    - 프록시의 필드에 직접 접근할 경우 아무 값도 조회할 수 없다.

## 상속관계와 프록시
프록시를 부모 타입으로 조회하면 부모의 타입을 기반으로 프록시가 생성된다.
- `instanceof` 연산을 사용할 수 없다.
- 하위타입으로 다운캐스팅을 할 수 없다.
> 지연로딩시에 부모의 타입으로 조회할 경우 부모의 타입을 기반으로 프록시가 생성된다.

### 해결방법1. `JPQL`로 대상 직접 조회
- 처음부터 자식 타입으로 직접 조회한다.
```java
Book jpqlBook = em.createQuery(
    "select b from Book b where b.id = :bookId", Book.class)
    .setParameter("bookId", item.getId())
    .getSingleResult();
```

### 해결방법2. 프록시 벗기기
```java
// 프록시 객체 처리
Item item = orderItem.getItem();
Item unProxyItem = unProxy(item);

if (unProxyItem instanceof Book) {
    System.out.println("proxyItem instanceof Book");
    Book book = (Book) unProxyItem;
    System.out.println("책 저자 = " + book.getAuthor());
}

Assert.assertTrue(item != unProxyItem);

// 하이버네이트가 제공하는 프록시에서 원본 엔티티를 찾는 기능을 사용하는 메소드
public static <T> T unProxy(Object entity) {
    if (entity instanceof HibernateProxy) {
        entity = ((HibernateProxy) entity)
            .getHibernateLazyInitializer()
            .getImplementation();
    }
    return (T) entity;
}
```
- `hibernate`가 제공하는 프록시에서 원본 엔티티를 찾는 기능(`unProxy`)을 사용하기
- 프록시에서 원본 엔티티를 직접 꺼내기 때문에 프록시와 원본 엔티티의 동일성 비교가 실패한다.
> 원본 엔티티가 꼭 필요한 곳에서만 잠깐 사용하고, 다른 곳에서는 사용되지 않도록 하는 것이 중요하다.
