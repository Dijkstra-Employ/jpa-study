# 13장. 웹 애플리케이션과 영속성 관리

# 13.1 트랜잭션 범위의 영속성 컨텍스트
## 스프링 컨테이너의 기본 전략
- 스프링 컨테이너는 `트랜잭션 범위의 영속성 컨텍스트 전략`을 기본으로 사용한다.
  - `트랜잭션의 범위`와 `영속성 컨텍스트`의 생존 범위가 같다.
- 트랜잭션을 시작할 때(보통 서비스 계층, `@Transactional`) 영속성 컨텍스트를 생성하고, 트랜잭션이 끝날 때 영속성 컨텍스트를 종료한다.
- 같은 `트랜잭션` 안에서는 항상 같은 `영속성 컨텍스트`에 접근한다.

### @Transactional
- `스프링 트랜잭션 AOP`는 대상 메서드를 호출하기 직전에 트랜잭션을 시작하고, 대상 메소드가 정상 종료되면 트랜잭션을 커밋하면서 종료한다.
  - 커밋하면 먼저 영속성 컨텍스트를 `flush`해서 db에 변경 내용을 반영한 후에 데이터베이스 트랜잭션을 `커밋`한다.
  - 예외가 발생하면 트랜잭션을 `롤백`하고 종료하는데 이때는 `flush`를 호출하지 않는다.

- **트랜잭션이 같으면 같은 영속성 컨텍스트를 사용한다.**
  - 엔티티 매니저는 달라도 같은 영속성 컨텍스트를 사용한다.
- **트랜잭션이 다르면 다른 영속성 컨텍스트를 사용한다.**
  - 스프링 컨테이너는 `스레드`마다 각각 다른 트랜잭션을 할당한다.
  - 멀티 스레드 환경에 안전하다.
> 트랜잭션과 복잡한 멀티 스레드 상황을 컨테이너가 처리해준다.

# 13.2 준영속 상태와 지연 로딩
- 스프링이나 J2EE 컨테이너는 `트랜잭션 범위의 영속성 컨텍스트 전략`을 기본으로 사용한다.
- 트랜잭션은 보통 `서비스 계층`에서 시작하므로 서비스 계층이 끝나는 시점에 **트랜잭션이 종료되면서 영속성 컨텍스트도 함께 종료**된다.
  - 조회한 엔티티가 **서비스와 리포지토리 계층**에서는 `영속 상태`를 유지하지만, **컨트롤러나 뷰 같은 표현 계층**에서는 `준영속 상태`가 된다.

### 준영속 상태
- 변경 감지와 지연 로딩이 동작하지 않는다.
- 초기화되지 않은 `프록시 객체의 초기화`를 시도할 경우 `LazyInitializationException` 예외가 발생한다.

### 준영속 상태의 지연 로딩 문제를 해결하는 방법
- **뷰가 필요한 엔티티를 미리 로딩해두는 방법**
  - 글로벌 Fetch 전략 수정 (FetchType 수정)
  - JPQL Fetch Join
  - 강제로 초기화
- **`OSIV`를 사용해서 엔티티를 항상 영속 상태로 유지하는 방법**

### 1. 글로벌 Fetch 전략 수정
- `지연 로딩`에서 `즉시 로딩`으로 변경한다.
  - 단점 1: 사용하지 않는 엔티티를 로딩한다.
  - 단점 2: `N+1` 문제가 발생한다.
> JPA가 JPQL을 분석해서 SQL을 생성할 때는 글로벌 페치 전략을 참고하지 않고 오직 JPQL 자체만 사용한다.

### 2. JPQL Fetch Join
- `Fetch Join`을 사용하면 `SQL JOIN`을 사용해서 `Fetch Join` 대상까지 함께 조회한다.
  - 함께 연관된 엔티티를 조회하기 때문에 `N+1 문제`가 발생하지 않는다.
- 단점 : 프레젠테이션 계층이 알게 모르게 데이터 접근 계층을 침범한다.
  - `화면`에 필요한 엔티티를 `데이터 접근 계층`에서 조회하므로 의존관계가 생긴다.
  - 뷰와 레포지토리 간의 논리적인 의존관계
- 적절한 선에서 타협점을 찾는 것이 중요하다.

### 3. 강제로 초기화
```java
@Transactional
public Order findOrder(id){
	Order order = orderRepository.findOrder(id);
	order.getMember().getName(); // 프록시 객체를 강제로 초기화한다.
	return order;
}
```
- 영속성 컨텍스트가 살아있을 때 `프레젠테이션 계층`이 필요한 엔티티를 **강제로 초기화해서 반환**하는 방법
  - 이미 초기화되었으므로 준영속 상태에서도 사용할 수 있다.
  - `hibernate`일 경우 `initialize()`를 이용해 프록시를 강제로 초기화할 수 있다.
- 단점 : 프록시를 초기화하는 코드를 서비스 계층이 담당하면 **뷰가 필요한 엔티티에 따라 서비스 계층의 로직을 변경해야 한다.**
  - 서비스 계층은 비즈니스 로직을 담당해야지 프레젠테이션 계층을 위한 일까지 하는 것은 좋지 않다.

### FACADE 계층 추가
- `FACADE` 계층 : 뷰를 위한 프록시 초기화를 담당한다.
  - Controller와 Service 사이에 위치한다.
- `서비스` 계층과 `프레젠테이션` 계층 사이에 **논리적인 의존성을 분리**할 수 있다.
  - 서비스 계층은 비즈니스 로직에 집중하고, 프레젠테이션 계층을 위한 초기화 코드는 `FACADE`가 담당한다.
    - 서비스 계층을 호출해서 비즈니스 로직을 실행한다.
    - 리포지토리를 직접 호출해서 뷰가 요구하는 엔티티를 찾는다.
- 단점
  - 중간에 계층이 하나 더 끼어든다.
  - 단순히 서비스 계층을 호출만 하는 위임 코드가 상당히 많다.

# 13.3 OSIV (Open Session In View)
- **영속성 컨텍스트를 `View`까지 열어둔다.**
- 영속성 컨텍스트가 살아있으면 엔티티는 `영속 상태`로 유지된다.
  - 뷰에서도 `지연 로딩`을 사용할 수 있다.

## 과거 OSIV : 요청 당 트랜잭션
- 클라이언트의 `요청`이 들어오자마자 서블릿 필터나 스프링 인터셉터에서 트랜잭션을 시작하고, `요청`이 끝날 때 트랜잭션도 끝낸다.
  - 영속성 컨텍스트가 처음부터 끝까지 살아있으므로 조회한 엔티티도 `영속 상태`를 유지한다.
  - 뷰에서도 지연 로딩을 할 수 있다.
- 단점: `Controller`나 `View` 같은 **프레젠테이션 계층이 엔티티를 변경할 수 있다**.
  - osiv는 뷰를 렌더링한 후에 트랜잭션을 `커밋`하는데, 영속성 컨텍스트를 `flush`할 때 **변경 감지 기능**이 작동하여 db에 반영된다.

### 프레젠테이션 계층에서 엔티티를 수정하지 못하게 막는 방법
1. 엔티티를 `읽기 전용 인터페이스`로 제공
2. `엔티티 Wrapping`
3. `DTO`만 반환

#### 엔티티를 `읽기 전용 인터페이스로 제공
- 읽기 전용 메서드만 제공하는 `읽기 전용 인터페이스`를 `View`에 제공한다.
```java
interface MemberView {
    public String getName();
}

@Entity
class Member implements MemberView {
}

class MemberService {
    public MemberView getMember(id) {
        return memberRepository.findById(id);
    }
}
```

#### 엔티티 Wrapping
- `getter`(읽기 전용 메서드)만 가지고 있는 **엔티티를 감싼 객체**를 만들고 프레젠테이션 계층에 반환한다.
```java
class MemberWrapper {
    private Member member;
    
    public MemberWrapper(member) {
        this.member = member;
    }
    
    // 읽기 전용 메서드만 제공
    public String getName() {
        member.getName();
    }
}
```

#### DTO만 반환
- 엔티티 대신에 단순 데이터 전달 객체인 `dto`를 생성해서 반환한다.
```java
class MemberDTO {
    private String name;
}

MemberDTO memberDTO = new MemberDTO();
memberDTO.setName(member.getName());
return memberDTO;
```

### 과거 OSIV인 요청 당 트랜잭션은 최근에는 거의 사용되지 않는다.
- 최근에는 이런 문제를 보완해서 `비즈니스 계층에서만 트랜잭션을 유지하는 방식`의 OSIV를 사용한다.
- `스프링 프레임워크가 제공하는 OSIV`가 뒤에 나올 방식을 사용한다.

## 스프링 OSIV : 비즈니스 계층 트랜잭션
- `hibernate osiv 서블릿 필터`
- `hibernate osiv 스프링 인터셉터`
- `hibernate oeiv 서블릿 필터`
- `hibernate oeiv 스프링 인터셉터`

### 스프링 OSIV 분석
- `요청당 트랜잭션 방식의 OSIV`는 **프리젠테이션 계층에서 데이터를 변경**할 수 있다는 문제가 있다.
- `스프링 프레임워크가 제공하는 OSIV`는 `비즈니스 계층에서 트랜잭션을 사용하는 OSIV`이다.
  - OSIV를 사용하지만 **트랜잭션은 비즈니스 계층에서만 사용**한다.
- 동작
  - 클라이언트의 `요청`이 들어오면 `영속성 컨텍스트`를 생성한다.
  - 서비스 계층에서 `트랜잭션`을 시작하면 생성해둔 영속성 컨텍스트에 `트랜잭션`을 시작한다.
  - 서비스 계층이 끝나면 `트랜잭션`을 `커밋`하면서 영속성 컨텍스트를 `flush`한다.
    - 트랜잭션만 종료하고 영속성 컨텍스트는 살려둔다.
  - 클라이언트 `요청`이 끝날 때 `영속성 컨텍스트`를 종료한다.
> 영속성 컨텍스트 생성 시기 != 트랜잭션 시작 시기

### 트랜잭션 없이 읽기
- `트랜잭션` 없이 엔티티를 `변경`하고 영속성 컨텍스트를 `flush`하면 `TransactionRequiredException`이 발생한다.
- 트랜잭션 없이 읽기: 엔티티를 변경하지 않고 단순히 조회만 할 때는 트랜잭션이 없어도 된다.
  - 영속성 컨텍스트는 `트랜잭션 범위 안에서` 엔티티를 `조회`하고 `수정`할 수 있다.
  - 영속성 컨텍스트는 `트랜잭션 범위 밖에서` 엔티티를 `조회`만 할 수 있다. (=트랜잭션 없이 읽기)
    프록시를 초기화하는 지연 로딩도 조회 기능이므로 트랜잭션 없이 읽기가 가능하다.
> 스프링이 제공하는 OSIV를 사용하면 프리젠테이션 계층에서는 트랜잭션이 없으므로 엔티티를 수정할 수 없다.
> 조회는 가능하므로 지연 로딩은 가능하다.

#### 비즈니스 계층 트랜잭션 정리
- **영속성 컨텍스트를 프리젠테이션 계층까지 유지**한다.
- `프리젠테이션 계층`에는 `트랜잭션`이 없으므로 **엔티티를 수정할 수 없다.**
  - 영속성 컨텍스트의 엔티티가 수정되지만 이미 트랜잭션이 커밋되면서 `flush`된 이후 수정되었으므로 **영속성 컨텍스트만 종료**된다. (db 반영 X)
- 프리젠테이션 계층에는 트랜잭션이 없지만 **트랜잭션 없이 읽기를 사용해서 지연 로딩을 할 수 있다.**
- 스프링 OSIV를 사용하면 **프리젠테이션 계층에서 엔티티를 수정해도 수정 내용을 db에 반영하지 않는다.**

### 스프링 OSIV 주의사항
- 프리젠테이션 계층에서 **엔티티를 수정한 직후에 새롭게 트랜잭션을 시작하는 서비스 계층을 호출**할 경우 문제가 생길 수 있다.
  - 트랜잭션을 `커밋`한 후 영속성 컨텍스트가 `flush` 되므로 **변경 감지가 동작하며 db에 변경사항이 반영된다**.
- 스프링 OSIV는 같은 영속성 컨텍스트를 여러 트랜잭션이 공유할 수 있으므로 문제가 발생한다.
  - osiv를 사용하지 않는 트랜잭션 범위의 영속성 컨텍스트 전략은 트랜잭션의 생명 주기와 영속성 컨텍스트의 생명 주기가 같으므로 문제가 발생하지 않는다.

## OSIV 정리
### - 스프링 OSIV 특징
- OSIV는 클라이언트의 요청이 들어왔을 때 영속성 컨텍스트를 생성해서 요청이 끝날때까지 같은 영속성 컨텍스트를 유지한다.
  - 따라서 한번 조회한 엔티티는 요청이 끝날 때까지 영속 상태를 유지한다.
- 엔티티 수정은 트랜잭션이 있는 계층에서만 동작한다.
  - 트랜잭션이 없는 프리젠테이션 계층은 지연 로딩을 포함해서 조회만 할 수 있다.

### - 스프링 OSIV 단점
- OSIV를 적용하면 같은 영속성 컨텍스트를 여러 트랜잭션이 공유할 수 있다.
  - 특히 트랜잭션 롤백을 주의해야한다.
- 프레젠테이션 계층에서 엔티티 수정 후 비즈니스 로직 호출시 엔티티가 수정될 수 있다.
- 프리젠테이션 계층에서 지연 로딩에 의한 sql이 실행된다.
  - 따라서 성능 튜닝시에 확인해야할 부분이 넓다.

### - `OSIV` vs `FACADE` vs `DTO`
- 준영속 상태가 되기전에 프록시를 초기화하거나, `OSIV`를 사용하는 방법이 있다.
- OSIV를 사용하면 화면 출력시 객체 그래프를 마음껏 탐색할 수 있다.
- 하지만, 복잡한 화면 구성시 처음부터 `jpql`을 작성해서 `dto`로 조회하는 것이 효과적이다.
### - OSIV는 같은 JVM을 벗어난 원격 상황에서는 사용할 수 없다.
- 결국 클라이언트가 필요한 데이터를 모두 json으로 생성하여 반환해야 한다.
- 외부 API의 경우 자주 변경되므로 dto로 변환해서 노출하는 것이 안전하다.

## 13.4 너무 엄격한 계층
- OSIV를 사용하기 전에는 프리젠테이션 계층에서 사용할 지연 로딩된 엔티티를 미리 초기화해야 했다.
  - 초기화는 서비스 계층이나 FACADE 계층이 담당했다.
- 하지만 **OSIV를 사용하면 영속성 컨텍스트가 프리젠테이션 계층까지 살아있으므로 미리 초기화할 필요가 없다.**
  - 따라서 단순한 엔티티 조회는 컨트롤러에서 리포지토리를 직접 호출해도 상관없다.

## 13.5 정리
- 스프링이나 J2EE 컨테이너 환경에서 JPA를 사용하면 **트랜잭션 범위의 영속성 컨텍스트 전략이 사용**된다.
  - 이 전략은 **트랜잭션 범위와 영속성 컨텍스트 생존 범위가 같다.**
    - **같은 트랜잭션 안에서는 항상 같은 영속성 컨텍스트에 접근한다**.
    - 단점으로는 프리젠테이션 계층에서 엔티티가 준영속 상태가 되므로 `지연 로딩`을 할 수 없다.
- `스프링 프레임워크가 제공하는 OSIV`를 사용하면 프리젠테이션 계층에서 지연로딩을 하면서도 엔티티를 수정하지 않는다.
