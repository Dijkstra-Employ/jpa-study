## 4주차

📌 **435~454**
**Querydsl 동적쿼리**

:pushpin: **동적쿼리 왜 필요해?**
정적 쿼리는 항상 **동일한 조건으로 데이터를 조회**한다.
하지만 실제 애플리케이션에서는 사용자 입력이나 상황에 따라 **쿼리 조건이 변경**되어야 하는 경우가 많다.

`Querydsl`에서는 이러한 동적쿼리를 작성하기 위해 `BooleanBuilder`를 지원한다.
`BooleanBuilder`은 여러 조건을 조합할 수 있는 빌더 클래스다.

:pushpin: 예시

```java
public List<Member> searchMembers(String name, Integer age, String city) {
    BooleanBuilder builder = new BooleanBuilder();

    if (StringUtils.hasText(name)) {
        builder.and(member.name.contains(name));
    }

    if (age != null) {
        builder.and(member.age.goe(age));
    }

    if (StringUtils.hasText(city)) {
        builder.and(member.address.city.eq(city));
    }

    return queryFactory
        .selectFrom(member)
        .where(builder)
        .fetch();
}
```

1. 검색 조건으로 이름,나이,도시를 받는다.
2. BooleanBuilder 초기화
3. 이름이 비어있지 않은 경우`만` 조건 추가
4. 나이가 null이 아닌 경우에`만` 조건 추가
5. 도시명이 비어있지 않은 경우에`만` 조건 추가
6. 마지막 `queryFactory.selectFrom(member).where(builder).fetch`
   에서 where절에 builder을 전달하여 앞서 동적으로 생성된 조건을 적용한다.

:pushpin: 주의사항

1. 동적쿼리를 작성할 때 `null체크`를 항상 하자.
   null체크를 하지 않으면 의도치 않은 쿼리 결과가 나올 수 있다.

2. **메서드 체인 활용**
   메서드 체인을 활용하여 쿼리 구조를 명확히 표현하고 조건을 별도의 메서드로 분리하여 `재사용성` 높인다.

```java
public List<Member> findActiveMembers(String name, Integer age) {
    return queryFactory
        .selectFrom(member)
        .where(member.status.eq(MemberStatus.ACTIVE))
        .where(
            nameEq(name),     // 따로 메서드로 분리 
            ageGoe(age)       // 따로 메서드로 분리
        )
        .orderBy(member.name.asc())
        .fetch();
}

private BooleanExpression nameEq(String name) {
    return StringUtils.hasText(name) ? member.name.eq(name) : null;
}

private BooleanExpression ageGoe(Integer age) {
    return age != null ? member.age.goe(age) : null;
}
```

📌 **455~469**
이번 내용에서는 중요한 개념 몇가지 소개되어 정리하려 한다.

**1. 벌크 연산**
- 엔티티를 수정할 때 보통 `변경감지`, 엔티티를 삭제할 때 보통 `remove()` 메소드를 사용하여 작업하지만
- 이러한 방법으로는 **수백,수천 개 이상의 엔티티**를 하나씩 처리하기에 무리가 있다.
- 이럴 때 `벌크 연산`을 사용한다.
```java
excuteUpdate();
```
- 결과 값은 벌크 연산으로 **영향을 받은 엔티티 건수 반환**
- 가장 중요하고 주의할 점은 벌크 연산은 **영속성 컨텍스트를 무시하고** 데이터베이스에 직접 쿼리를 한다.
- 따라서 벌크 연산을 하고 난 이후의 **데이터베이스 값과 영속성컨텍스트의 값의 불일치**가 일어날 수 있다.
- 해결방법으로는 대표적으로 `em.refresh()`를 사용

**2. 영속성 컨텍스트와 JPQL**
- JPQL로 엔티티를 조회하면 영속성 컨텍스트에서 관리되지만 **엔티티가 아니면 영속성 컨텍스트에서 조회하지 않는다.**
- 예를 들어 `임베디드타입`이나 `단순 필드`를 select로 조회하는 동작은 **영속성 컨텍스트에서 관리되지 않는다.**

**3. JPQL로 조회한 엔티티와 영속성 컨텍스트**
- 예를 들어 영속성 컨텍스트에 회원1이 있는데 JPQL로 회원1을 다시 조회하면 어떠한 일이 일어날까?
- 결론은 **JPQL로 데이터베이스에서 조회한 결과를 버리고 대신에 영속성 컨텍스트에 있던 엔티티를 반환**한다.
- 근데 왜 데이터베이스에 있는 값으로 대체해서 반환하면 안될까???
- 답은 `동일성 보장`이다.
- 영속성 컨텍스트는 영속 상태인 엔티티의 동일성을 보장한다.

**4. find() vs JPQL**
- 우리는 앞서 `em.find()`를 배웠다.
- 이는 엔티티를 영속성 컨텍스트에서 먼저 찾고 없으면 데이터베이스에서 찾는
- 즉, 영속성 컨텍스트에 있으면 메모리에서 바로 찾는 성능상 이점을 가지고 있다. `(1차캐시)`
- JPQL은 어떻게 동작할까?
- JPQL은 항상 데이터베이스에 SQL을 실행하여 결과를 조회한다.
- JPQL은 데이터베이스를 `먼저` 조회하고 만약 영속성 컨텍스트에 이미 조회한 엔티티가 있다면
- **새로 검색한 엔티티는 버리고 영속성 컨텍스트에 있는 기존 엔티티를 반환**한다. (동일성 보장)

📌 **470 ~ 496**
책에서는 환경설정을 `xml`(옛날 방식..)로 했는데 `yaml` 또는` properties` 설정과의 **차이점**은 뭘까?

- 먼저 `XML`설정과 `YAML `설정은 모두 스프링 부트에서 **애플리케이션의 구성을 정의**하는 방법 중 하나이다.

### XML 설정
1. **설정이 분리**되어 있기 때문에, 설정 파일을 통해 애플리케이션의 구성 요소를 명확하게 이해할 수 있다.
2. **XML형식은 가독성이 떨어진다**.
3. 코드 내에서 **동적으로 설정을 변경하기 어렵다**.

### YAML 설정
1. **가독성이 뛰어나며**, 설정 내용을 쉽게 파악할 수 있다.
2. 다양한 환경에 맞춰 **프로파일**을 쉽게 관리할 수 있다.
3. **들여쓰기**에 민감하기 때문에, 잘못된 들여쓰기가 오류를 유발할 수 있다.

정리하자면 `XML`은 명확성과 기존 시스템의 호환성에서 강점을 가지며, `YAML`은 가독성과 간결함에서 유리하다.
번외로 아까 `XML`이 옛날 방식이라 했는데, 시간이 지나면서 `YAML`이나 `Java 기반 설정`과 같은 **더 직관적이고 간결한 방법**들이 등장하면서, XML 사용은 점점 줄어들고 있기 때문이다!

📌 **497~517**
최근 성능에 관심이 많아 `PersistenceContext`를 사용할 때의 성능 최적화에 관해 알아보려한다.

1. **적절한 캐시 관리**: 영속성 컨텍스트는 1차 캐시 역할을 하지만, 과도한 엔티티 보관은 메모리 사용량을 증가시킬 수 있다.
   따라서 필요에 따라 **영속성 컨텍스트를 초기화하거나 분리하는 작업**이 필요할 수 있다.

2. **N+1 문제 방지**: 연관 엔티티를 조회할 때 발생할 수 있는 `N+1 쿼리 문제`를 주의해야 한다.
   필요한 경우 ’즉시 로딩‘이나 ’페치 조인‘을 사용하여 쿼리 수를 줄일 수 있다.

3. **지연 로딩 활용**: 불필요한 데이터 로딩을 방지하기 위해 `지연 로딩`을 적절히 사용해야 한다.
   단, 지연 로딩 사용 시 `프록시 객체`로 인한 성능 저하에 주의해야 한다.

4. **벌크 연산 주의**: 대량의 데이터를 처리할 때는 벌크 연산을 고려해야 하지만, 영속성 컨텍스트와의 **동기화 문제에 주의**해야 한다.

5. **적절한 플러시 전략**: 불필요한 플러시 호출을 줄이고, 필요한 시점에만 플러시를 호출하여 **데이터베이스 동기화 비용을 최소화**해야 한다.

📌 **517 ~ 536**
## 도메인 모델 패턴
- **비즈니스 로직의 위치**: 도메인 모델 패턴에서는 엔티티가 자신의 상태와 행동을 **캡슐화**하여 비즈니스 로직을 포함한다.

### 장점
- **비즈니스 규칙의 명확성**: 비즈니스 로직이 엔티티와 밀접하게 연결되어 있다. 따라서 규칙을 이해하고 수정하기 쉽다.
- **유지 보수성**: 도메인 객체가 스스로 행동을 정의하므로, 변경 시 관련 로직을 한 곳에서 관리할 수 있다.
- **객체 지향적 접근**: 객체 지향의 장점을 살려 코드의 재사용성과 확장성을 높일 수 있다.

### 단점
- **복잡성**: 초기 설계가 복잡할 수 있어, 도메인 모델이 커지면 관리가 어려워질 수 있다.
- **성능 문제**: 많은 엔티티가 메모리에 로드되고 상태를 유지해야 하므로, **성능 저하**가 발생할 수 있다.

## 트랜잭션 스크립트 패턴
- **비즈니스 로직의 위치**: 트랜잭션 스크립트 패턴에서는 **비즈니스 로직이 서비스 계층이나 스크립트에 위치**하며, 엔티티는 단순히 데이터 저장소 역할을한다.

### 장점
- **단순성**: 구현이 간단하고 직관적이다. 따라서 빠르게 개발할 수 있다.
- **성능**: 엔티티가 단순하므로 메모리 사용량이 적고 성능이 좋을 수 있다.

### 단점
- **유지 보수성**: 비즈니스 로직이 여러 스크립트에 분산되어 있어, 변경 시 여러 곳을 수정해야 할 수 있다.
- **코드 중복**: 비슷한 로직이 여러 스크립트에 중복될 수 있어, 코드 관리가 어렵고 오류가 발생할 가능성이 높다.
- **비즈니스 규칙의 분산**: 비즈니스 로직이 엔티티와 분리되어 있어, 전체 시스템의 비즈니스 규칙을 이해하기 어려울 수 있다.

따라서 **비즈니스 요구 사항과 애플리케이션의 복잡성**에 따라 최적의 방법을 결정하는 것이 중요하다.