# 책 내용 정리

### [0711] 244~265

**상속 관계 매핑**

1. 각각의 테이블로 변환 (조인 전략) : `InheritanceType.JOINED`
    * 엔티티 각각을 모두 테이블로 만들고 자식 테이블이 부모 테이블의 기본키를 받아서 기본키+외래키로 사용하는 전략
2. 통합 테이블로 변환 ((단일 테이블 전략) : `InheritanceType.SINGLE_TABLE`
    * 테이블을 하나만 사용하고 구분 컬럼으로 구분, 가장 빠르다
3. 서브타입 테이블로 변환 (구현 클래스마다 테이블 전략) - 비추 : `InheritanceType.TABLE_PER_CLASS`
    * 자식 엔티티마다 테이블을 만들고 각 테이블에 필요한 컬럼이 다 있다.

**@MappedSuperclass**
매핑 정보를 상속할 목적으로 사용, 실제 테이블과 매핑 X

**식별관계 vs 비식별관계**

* 식별 관계: 부모 테이블의 기본 키를 내려받아서 자식 테이블의 기본키+외래키로 사용
* 비식별 관계: 부모 테이블의 기본키를 받아서 자식 테이블의 외래키로만 사용
    * 필수적(null 허용X), 선택적(null 허용)

**복합키**

* jpa에서 식별자를 둘 이상 사용하려면 별도의 식별자 클래스를 만들어야한다.
- `@IdClass` : 관계형 db에 가까운 방법
- `@EmbeddedId` : 객체지향에 가까운 방법

❓ 조인 전략시 insert sql을 두번 실행하는 이유? (247p)

❓ `@IdClass`에서 식별자 클래스에 기본 생성자가 있어야하는 이유? (258p)

❓ 복합키에 `@GeneratedValue`를 사용할 수 없는 이유? (262p)

❓ `@IdClass`와` @EmbeddedId` 복합키 식별관계 매핑이 이해가 안가네요(262p~)

### [0712] 266~285

**비식별관계**

* 식별 관계에 비해 매핑도 쉽고 코드도 단순하다.

**일대일 식별 관계**

* 자식 테이블의 기본 키 값으로 부모 테이블의 기본 키 값만 사용

**식별** 관계 vs **비식별** 관계

* 데이터베이스 설계 관점과 객체 관계 매핑 관점에서 모두 식별 관계보다 비식별 관계를 선호한다.

**데이터베이스 설계 관점**

* **식별 관계**
    * 자식 테이블의 기본 키 컬럼이 늘어난다. 조인할 때 sql문이 복잡해지고 기본 키 인덱스가 불필요하게 커진다.
    * 복합 기본 키를 만들어야하는 경우가 많다.
    * 자연 키 컬럼을 조합하는 경우가 많은데, 후에 변경하기 어렵다.
* **비식별 관계**
    * 비즈니스와 관계없는 대리키를 사주로 사용하므로 변경하기 쉽다.

**객체 관계 매핑 관점**

* **식별 관계**
    * jpa는 별도의 복합 키 클래스르 만들어서 사용해야한다.
    * 장점으로는 기본 키 인덱스를 활용하기 좋고, 하위 테이블만으로 검색을 완료할 수 있다.
* **비식별 관계**
    * jpa는 `@GeneratedValue`를 통해 대리키를 편리하게 생성할 수 있다.

***=> 추천 방법 : 비식별 관계를 사용하고 기본키는 Long 타입의 대리키를 사용한다. 왠만하면 필수적 비식별관계를 사용하는 것이 좋다. (null X, 외부 조인 안하고 내부 조인만 사용해도 된다.)***

**조인 테이블**
a) 조인 컬럼 사용 (외래키) : `@JoinColumn`
b) 조인 테이블 사용(테이블 사용) : `@JoinTable`

* 조인 테이블은 테이블을 하나 더 추가해야하므로 관리해야할 테이블이 늘어나고 조인시 조인 테이블까지 추가로 조인해야한다.

***=> 추천 방법: 기본으로는 조인 컬럼을 사용하고, 필요할 경우 조인 테이블을 사용하자.***

엔티티 하나에 여러 테이블 매핑 : `@SecondaryTable`

* 항상 두 테이블을 조회해야하므로 최적화하기 어렵다.

***=> 테이블당 엔티티를 각각 만들어서 일대일 매핑하는 것을 권장한다.***

❓ 조인 테이블에 컬럼을 추가하면 `@JoinTable` 전략을 사용할 수 없는 이유? (278p)

### [0713] 288 ~ 308

**프록시**

* 실체 객체 아닌 데이터베이스 조회를 지연할 수 있는 가짜 객체 (지연 로딩 지원)
* `e,getReference(Member.class, "member1");`
* 실제 객체에 대한 참조 보관 : `target`
* 실제 객체의 **식별자 값**을 가지고 있다.
* 연관관계 설정시 sql을 실행하지 않는다.
* **프록시 객체의 초기화** : 프록시 객체를 실제 사용하면 db에서 조회하여 실제 엔티티 객체를 생성한다.

**지연 로딩** `(FetchType.LAZY)`

* 엔티티가 실제 사용할 때까지 db 조회를 지연하는 방법
* 프록시를 사용하거나 바이트코드를 수정하여 구현

**즉시 로딩** `(FetchType.EAGER)`

* 엔티티를 조회할 때 연관된 엔티티도 함께 조회

***=> FetchType 선택 기준 : 자주 함께 사용할 경우 즉시 로딩, 가끔 함께 사용할 경우 지연 로딩***

**jpa 기본 Fetch 전략**

* `@XXToOne` : 즉시 로딩
* `@XXToMany` : 지연 로딩

***=> 추천 방법 : 모든 연관관계에 지연 로딩을 사용하고, 필요한 경우 즉시 로딩을 사용하자.***

**null 제약 조건**

* **선택적 관계**이면 **외부 조인**을 사용하고 **필수 관계**면 **내부 조인**을 사용한다.

**영속성 전이 : **`CASCADE`
특정 엔티티를 영속 상태로 만들 때 연관된 엔티티도 함께 영속 상태로 만들고 싶은 경우

❓ 연관된 엔티티는 영속성 컨텍스트에서 영속 상태인가? 프록시 객체도 영속 상태인가? (293p)

❓ 연관관계 설정시 엔티티 접근 방식을 필드로 설정해도 프록시를 초기화하지 않는 이유 (295p)

❓ 양방향일때 연관관계 주인이 아니어도 fetchType 설정이 가능한가? (302p)

❓ 컬렉션 즉시 로딩이 항상 외부 조인을 사용하는 이유? @XXToMany인데 연관된 엔티티가 하나도 없을 수가 있는지? (306p)

### [0714] 309~329

**영속성 전이**

* 저장 : `CascadeType.PERSIST`, 부모와 자식 한번에 영속화
* 삭제 : `CascadeType.REMOVE`, 부모와 자식 엔티티 모두 제거
* 병합 : `CascadeType.MERGE,` 부모와 자식 한번에 병합(detach->persist)
* refresh : `CascadeType.REFRESH`, 부모와 자식 한번에 refresh(새로고침), db의 최신 상태 반영
* detach:` CascadeType.DETACH`, 부모와 자식 한번에 detach
* all : `CascadeType.ALL`, 모든 옵션 포함

**고아 객체** : `orphanRemoval=false`

* 부모 엔티티와 연관관계가 끊어진 자식 엔티티를 자동으로 삭제
* 부모 엔티티의 컬렉션에서 자식 엔티티의 참조만 제거하면 자식 엔티티가 자동으로 삭제

**영속성 전이 + 고아 객체**
CascadeType.ALL + orphanRemoval=true 사용시 부모 엔티티를 통해서 자식 엔티티들의 생명주기 관리 가능

**JPA 데이터 타입**

* 엔티티 타입(`@Entity`)
* 값 타입 (java 기본 타입이나 객체)

**값 타입**

* 기본값 타입
    * 자바 기본 타입 (int, double)
    * 래퍼 클래스 (Integer)
    * String
* 임베디드 타입
* 컬렉션 값 타입

**기본값 타입**

* 생명주기를 엔티티에 의존한다.
* 공유하면 안된다.

**임베디드 타입**: `@Embeddable`, `@Embedded`

* 직접 정의한 임베디드 타입도 값 타입으로 이루어져 있다.
* 값 타입을 이용하면 재사용이 가능하고 응집도가 높아진다.
* 합성 관계이다.

=> 잘 설계한 ORM 애플리케이션은 매핑한 테이블의 수보다 클래스의 수가 더 많다.

* 속성 재정의 : `@AttributeOverride`
* 한 엔티티에 같은 임베디드 타입을 중복해서 사용할때 사용한다.
* 임베디드 타입이 null이면 매핑한 컬럼 값은 모두 null이 된다.

**값 타입 공유 참조**

* 값 타입을 여러 엔티티에서 공유하면 위험하다. 같은 참조를 가지고 있기 때문에 부작용이 일어난다.

❓ cascade에서 persist와 remove를 사용할때 플러시를 호출할때 전이가 발생하는 이유? + cascade 사용 예시 (311p)

❓ orphanRemoval=true로 하면 연관관계 메서드에서 한쪽만 제거하면 될까? (312p)

❓ DDD의 Aggregate Root ? 객체 그래프를 탐색하는 것과 프록시 기술의 연관성? (313p)

❓ 엔티티를 영속 상태로 만들어서 db에 저장할때 연관된 엔티티도 모두 영속 상태여야하는 이유? (315p)

### [0715] 330~350

**불변 객체**

* 값 타입에서 값일 경우 복사해서 넘기고, 객체일 경우 참조를 넘긴다.
* 객체의 공유 참조라는 부작용을 막기 위해 불변 객체를 사용하자.

**동일성 vs 동등성 비교**

* 동일성(==), 참조값 비교
* 동등성(equals()), 값 비교

값 타입 컬렉션 `@ElementCollection`, `@CollectionTable`

* 컬럼 안에 컬렉션을 저장하기 위해 별도의 테이블을 추가하여 매핑한다.
* 기본 FetchType은 `LAZY`이다.
* 임베디드 타입은 엔티티 sql에 포함되지만, 값 타입 컬렉션은 다른 테이블이므로 매번 sql이 실행된다.

***=> 추천 방법: 값 타입 컬렉션을 사용하지말고 일대다 + 영속성 전이(cascade) + 고아객체제거(orphanRemoval)를 수행하자.***

# Q&A 정리

## 1. 상속 관계 매핑

### ❓ Q: 상속관계에서 조인 전략시 insert SQL을 두 번 실행하는 이유? (247p)

A: 조인 전략에서는 부모 테이블과 자식 테이블이 분리되어 있다.
하나의 엔티티를 저장할 때:

1. 부모 테이블에 대한 insert
2. 자식 테이블에 대한 insert

이렇게 총 두 번의 SQL이 필요하다.
> 부모 테이블의 엔티티가 이미 존재할 경우 insert는 한번만 수행한다.

예를 들어, 'Person'이라는 부모 클래스와 이를 상속받는 'Employee'라는 자식 클래스가 있다고 가정해보자.

```java

@Entity
@Inheritance(strategy = InheritanceType.JOINED) // 부모 테이블과 자식 테이블을 각각 만든다.
public class Person {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;
    private int age;
}

@Entity
public class Employee extends Person {
    private String company;
    private String position;
}
```

> @Inheritance(strategy = InheritanceType.JOINED) // 부모 테이블과 자식 테이블을 각각 만든다.

이제 새로운 Employee 객체를 생성하고 이를 데이터베이스에 저장하려 할 때, JPA는 두 개의 INSERT 문을 실행한다.

1. Person 테이블에 INSERT: 기본 정보(id, name, age)를 저장
2. Employee 테이블에 INSERT: 직원 특정 정보(id(person을 참조하는 외래키), company, position)를 저장

## 2. 복합키 관련

### ❓ Q: @IdClass에서 식별자 클래스에 기본 생성자가 있어야하는 이유? (258p)

A: JPA가 **[[리플렉션]]** 을 사용하여 엔티티를 생성할 때 기본 생성자를 사용한다.
**@IdClass로 지정된 클래스도 JPA에 의해 인스턴스화**되므로 기본 생성자가 필요하다.

### ❓ Q: 복합키에 @GeneratedValue를 사용할 수 없는 이유? (262p)

A: 복합키는 여러 필드로 구성되어 있어 **단일 값을 자동 생성하는 @GeneratedValue**을 사용하는 것이 적합하지 않다.
또한 복합키의 각 부분은 개별적으로 의미를 가져야 하므로, 자동 생성은 적합하지 않다.

### ❓ Q: @IdClass와 @EmbeddedId 복합키 식별관계 매핑이 이해가 안가네요 (262p~)

A:

- **@IdClass**: **별도의 식별자 클래스를 사용**하고, **엔티티 클래스의 필드와 식별자 클래스의 필드를 매핑**한다.
- **@EmbeddedId**: 복합 키 클래스를 **엔티티에 직접 포함**시킵니다.
  둘 다 복합키를 표현하는 방법이지만, @EmbeddedId가 좀 더 객체지향적이다.

## 3. 조인 테이블

### ❓ Q: 조인 테이블에 컬럼을 추가하면 @JoinTable 전략을 사용할 수 없는 이유? (278p)

A: **@JoinTable**은 순수한 연관관계를 표현하기 위한 것이다.
추가 컬럼이 있다면 이는 단순한 연관관계 이상의 의미를 가지므로, 이 경우 별도의 엔티티로 만들어 관리하는 것이 더 적합하다.
> 추가 컬럼이 존재할 경우, 엔티티로 만들기!

## 4. 프록시와 로딩 전략

### ❓ Q: 연관된 엔티티는 영속성 컨텍스트에서 영속 상태인가? 프록시 객체도 영속 상태인가? (293p)

A:

- 연관된 엔티티: 이미 로드되었다면 영속 상태이다.
- **프록시 객체: 초기화되지 않았더라도 영속성 컨텍스트가 관리하므로 영속 상태로 볼 수 있다.**(영속 상태로 취급)

- **즉시 로딩** : 주 엔티티와 연관 엔티티가 **함께 영속 상태**
- **지연 로딩**
    1. 주 엔티티를 로드할 때:
        - **연관 엔티티는 즉시 로드되지 않고, 대신, 프록시 객체가 생성**된다.
    2. 프록시 객체의 상태:
        - 영속성 컨텍스트에 의해 관리되므로 **'영속' 상태로 간주**될 수 있다.
        - 하지만 실제 데이터는 아직 로드되지 않은 상태이다.
    3. 연관 엔티티 접근 시:
        - 프록시 객체의 메서드를 처음 호출할 때 실제 데이터가 로드된다.
        - 이때 데이터베이스 조회가 발생하고, 실제 엔티티 객체로 초기화된다.
        - **초기화 후에는 완전한 '영속' 상태가 된다.**

### ❓ Q: 연관관계 설정시 엔티티 접근 방식을 필드로 설정해도 프록시를 초기화하지 않는 이유 (295p) ??

A: 필드 접근 방식을 사용하면 JPA가 필드에 직접 접근하므로 getter 메소드를 호출하지 않는다. 따라서 프록시 초기화가 발생하지 않는다.

JPA에서 엔티티에 접근하는 방식은 2 종류가 있다.

1. 필드 접근 방식 (@Access(AccessType.FIELD))
2. 프로퍼티 접근 방식 (@Access(AccessType.PROPERTY))

#### 필드 접근 방식의 특징:

1. JPA가 엔티티의 필드에 직접 접근한다.
2. **getter/setter 메소드를 사용하지 않는다.**

#### 프록시 객체와의 관계:

1. 프록시 객체는 실제 데이터를 가져오는 것을 지연시키는 역할을 한다.
2. **보통 프록시 객체는 getter 메소드가 호출될 때 초기화됩니다.**

필드 접근 방식을 사용할 때:

1. **JPA는 필드에 직접 접근하므로 getter 메소드를 호출하지 않는다.**
2. **getter 메소드를 호출하지 않으므로, 프록시 객체가 초기화되지 않는다.** => 프록시 객체 그대로 반환

> 이를 통해 불필요한 데이터 로딩을 방지한다.

결론적으로, 지연 로딩 사용시 필드 접근 방식은 JPA가 엔티티를 더 효율적으로 관리할 수 있게 해준다.
> 여전히 실제 데이터 접근시에는 `user.getDepartment().getName()`을 호출하면 프록시 초기화 발생

> 프로퍼티 접근 방식에서는 getter 메서드 호출로 인해 프록시 초기화가 더 쉽게 발생할 수 있다.

### ❓ Q: 양방향일 때 연관관계 주인이 아니어도 fetchType 설정이 가능한가? (302p)

A: 가능하다.
**연관관계의 주인 여부와 상관없이 양쪽 모두 fetchType을 설정할 수 있다**. FetchType은 **각 엔티티를 조회할 때의 동작**을 결정하기 때문이다.

### ❓ Q: 컬렉션 즉시 로딩이 항상 외부 조인을 사용하는 이유? @XXToMany인데 연관된 엔티티가 하나도 없을 수가 있는지? (306p)

A: @XXToMany 관계에서는 연관된 엔티티가 없을 수 있다.
내부 조인을 사용하면 연관 엔티티가 없는 경우 주 엔티티도 조회되지 않을 수 있으므로, 항상 데이터를 가져오기 위해 외부 조인을 사용한다.

#### 컬렉션 즉시 로딩(Eager Loading)이 항상 외부 조인(Outer Join)을 사용하는 이유

데이터 무결성을 보장하기 위해서이다.

- **컬렉션 관계(예: @OneToMany, @ManyToMany)에서는 관련 데이터가 없을 수 있다.**
- 내부 조인(Inner Join)을 사용하면, 관련 데이터가 없는 엔티티는 결과에서 제외된다.
- **외부 조인을 사용하면 관련 데이터가 없어도 주 엔티티를 조회할 수 있습니다.**

> 사용자가 즉시 로딩을 설정했다면, 모든 관련 데이터를 기대할 것이다.
> **내부 조인을 사용하면 주 엔티티의 일부 데이터가 누락될 수 있어 예상치 못한 결과를 초래할 수 있다.**

3. 예시:
   ```java
   @Entity
   public class Order {
       @Id
       private Long id;
       
       @OneToMany(mappedBy = "order", fetch = FetchType.EAGER)
       private List<OrderItem> items;
   }
   ```
    - 이 경우, 주문(Order)을 조회할 때 주문 항목(OrderItem)이 없는 주문도 조회되어야 합니다.
    - **내부 조인을 사용하면 주문 항목이 없는 주문은 결과에서 제외된다.**

## 5. 영속성 전이와 고아 객체

### ❓ Q: cascade에서 persist와 remove를 사용할 때 플러시를 호출할 때 전이가 발생하는 이유? + cascade 사용 예시 (311p)

A:

#### 1. 전이(Cascading)란?

- 엔티티의 상태 변화를 연관된 엔티티에게 전파하는 것
- ex) 부모 엔티티를 저장할 때 자식 엔티티도 함께 저장

#### 2. CascadeType.PERSIST와 CascadeType.REMOVE

- **PERSIST**: 부모 엔티티 저장 시 자식 엔티티도 함께 저장
- **REMOVE**: 부모 엔티티 삭제 시 자식 엔티티도 함께 삭제

#### 3. 플러시(Flush)란?

- **영속성 컨텍스트의 변경 내용을 데이터베이스에 반영하는 과정**이다.

#### 4. 플러시 시 전이가 발생하는 이유

- JPA는 성능 최적화를 위해 실제 데이터베이스 작업을 최대한 지연시킨다.
- **PERSIST와 REMOVE 작업은 데이터베이스에 직접적인 영향을 주는 작업이므로, 실제 데이터베이스 반영 시점(플러시)에 수행된다. - 작업이 지연될 수 있다.**

#### 5. 다른 Cascade 옵션과의 차이

- **MERGE**: 병합 작업은 즉시 수행될 수 있다.
- **REFRESH**: 데이터베이스로부터 즉시 새로고침 가능하다.
    - SELECT 쿼리를 통해 데이터베이스에서 최신 데이터를 조회한다. (read-only)
- DETACH: 영속성 컨텍스트에서 즉시 분리 가능하다.
  => PERSIST/REMOVE는 데이터 변경 작업이므로 플러시 시점까지 지연될 수 있다.

### ❓ Q: orphanRemoval=true로 하면 연관관계 메서드에서 한쪽만 제거하면 될까? (312p)

A: orphanRemoval=true로 설정하면 부모 엔티티에서 자식 엔티티의 참조만 제거해도 자식 엔티티가 삭제된다.
> 하지만 일관성을 위해 양쪽 관계를 모두 관리하는 것이 좋다.

## 6. DDD와 JPA

### ❓ Q: DDD의 Aggregate Root? 객체 그래프를 탐색하는 것과 프록시 기술의 연관성? (313p)

A:
Aggregate Root는 관련 엔티티 그룹의 진입점이다.
JPA의 프록시 기술은 Aggregate Root 개념에 따라 필요할 때만 관련 객체를 로딩함으로써 객체 그래프 탐색을 효율적으로 수행할 수 있다.
=> 프록시를 통해 객체 그래프를 탐색할 때, **실제로 접근하는 객체만 프록시를 초기화**된다.
이를 통해 성능을 최적화할 수 있고 큰 객체 그래프도 효율적으로 다룰 수 있다.

#### 1. DDD (Domain-Driven Design)란?

- 비즈니스 도메인을 중심으로 소프트웨어를 모델링한다.

#### 2. Aggregate Root:

- 연관된 객체들의 집합(Aggregate)을 대표하는 엔티티이다.
- **외부에서 Aggregate 내부 객체에 접근할 때 반드시 Aggregate Root를 통해야 한다.**

#### 3. 객체 그래프 탐색:

- 연관된 객체들 사이를 이동하며 데이터를 조회하는 것을 말한다. (. 사용)
- 예: 주문(Order) -> 주문 항목(OrderItem) -> 상품(Product)

#### 4. JPA의 프록시 기술:

- 실제 객체 대신 가짜 객체(프록시)를 사용하여 필요할 때만 실제 데이터를 로딩한다.
- 성능을 최적화하고 불필요한 데이터 로딩을 방지할 수 있다.

#### 5. Aggregate Root와 프록시 기술의 연관성:

- Aggregate Root를 통해 연관 객체에 접근할 때, 프록시를 사용하여 필요한 시점에만 데이터를 로딩할 수 있다.
- 대규모 객체 그래프 탐색시 성능을 크게 향상시킬 수 있다.

6. 예시:
   ```java
   @Entity
   public class Order { // Aggregate Root
       @Id
       private Long id;

       @OneToMany(mappedBy = "order", fetch = FetchType.LAZY) // 지연 로딩
       private List<OrderItem> items;

   }

   @Entity
   public class OrderItem {
       @ManyToOne(fetch = FetchType.LAZY)
       private Product product;

   }
   ```

결론적으로, JPA의 프록시 기술은 DDD의 Aggregate Root 개념을 효과적으로 구현할 수 있게 해준다.

### ❓ Q: 엔티티를 영속 상태로 만들어서 DB에 저장할 때 연관된 엔티티도 모두 영속 상태여야하는 이유? (315p)

A: 데이터 일관성을 유지하기 위해서이다. 연관된 엔티티가 영속 상태가 아니면 JPA가 이를 관리할 수 없어 **데이터 불일치가 발생**할 수 있다.

## 7. 값 타입

### ❓ Q: 332p에서 protected 생성자 사용 이유?

A: 값 타입은 변경 불가능해야한다. protected 생성자를 사용하면 외부에서 직접 인스턴스를 생성하는 것을 방지하고 제어할 수 있다.

### 임베디드 타입을 불변으로 만드는 이유?

JPA에서 값 타입은 크게 두 가지로 나뉜다.

1. 기본값 타입: int, String 등의 자바 기본 타입이나 래퍼 클래스
2. 임베디드 타입: @Embeddable 어노테이션을 사용한 복합 값 타입 (예: Address)

#### 1. 안전하게 공유 가능하다.

여러 엔티티가 같은 Address 인스턴스를 공유할 수 있습니다.
만약 Address가 변경 가능하다면, 한 엔티티에서의 변경이 다른 엔티티에도 영향을 미칠 수 있다.

   ```java
   User user1=new User();
        User user2=new User();
        Address address=new Address("123 Main St","City");

        user1.setAddress(address);
        user2.setAddress(address);

        // 만약 Address가 변경 가능하다면 ??
        address.setStreet("456 Elm St");  // user1과 user2의 주소가 모두 변경됨
   ```

#### 2. 부작용 방지

값 타입은 엔티티의 속성으로 사용되며, 독립적인 생명주기를 갖지 않는다. 변경이 가능하다면 예기치 않은 부작용이 발생할 수 있다.

#### 3. 일관성 유지

JPA는 값 타입의 변경을 감지하지 않습니다.(식별자가 존재하지 않기 때문이다.)
변경 가능하다면 데이터베이스와의 일관성을 유지하기 어렵다.

#### 4. 의도 표현이 명확하다

주소 변경이 필요한 경우, 새로운 Address 객체를 생성하여 교체하는 것이 변경의 의도가 명확하다.

   ```java
   user.changeAddress(new Address("456 Elm St","New City"));
   ```

#### 5. 동시성 처리

불변 객체는 여러 스레드에서 안전하게 공유될 수 있다.

### ❓ Q: 값 타입 컬렉션이 영속성 전이와 고아 객체 기능을 필수로 가진다고 볼 수 있는 이유? (337p)

A: 값 타입은 독립적인 생명주기를 가지지 않고 소유한 엔티티에 종속적이기 때문이다.
따라서 **소유 엔티티의 상태 변화에 따라 항상 함께 처리되어야 한다.**

#### 1. 값 타입의 특성

- 값 타입은 독립적인 식별자를 갖지 않는다.
- **항상 특정 엔티티에 종속된다.**

#### 2. 영속성 전이(Cascade)

- **값 타입 컬렉션은 소유 엔티티와 생명주기를 공유한다.**
- 소유 엔티티가 저장, 삭제될 때 값 타입 컬렉션도 함께 저장, 삭제된다.

#### 3. 고아 객체 제거

- **값 타입 컬렉션에서 요소를 제거하면, 그 요소는 데이터베이스에서도 삭제되어야 한다.**
- 고아 객체 제거 기능과 유사하다.

4. 예시:
   ```java
   @Entity
   public class User {
       @ElementCollection
       private Set<String> phoneNumbers = new HashSet<>();
   }
   ```

   이 경우:
    - User 엔티티가 저장될 때 phoneNumbers도 함께 저장 (영속성 전이)
    - phoneNumbers에서 요소를 제거하면, 데이터베이스에서도 삭제(고아 객체 제거와 유사)

=>  **개발자가 별도로 설정할 필요 없이, JPA는 값 타입 컬렉션에 대해 이러한 동작을 수행한다.** (JPA가 설계시 결정한 것이다.)

### ❓ Q: 값 타입 컬렉션을 매핑하는 테이블은 모든 컬럼을 묶어서 기본 키를 구성해야하는 이유? (339p)

**A: 값 타입은 식별자가 없으므로, 모든 컬럼을 조합해 유일성을 보장해야 한다.** 

