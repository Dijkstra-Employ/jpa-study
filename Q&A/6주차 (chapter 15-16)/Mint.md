### [0806] 661~681
### 상속관계와 프록시
프록시를 부모 타입으로 조회하면 부모의 타입을 기반으로 프록시가 생성된다.
- `instanceof` 연산을 사용할 수 없다
- 하위타입으로 다운캐스팅을 할 수 없다,
> 지연로딩시에 부모의 타입으로 조회할 경우 부모의 타입을 기반으로 프록시가 생성된다.

### 해결방법1. `JPQL`로 대상 직접 조회
- 처음부터 자식 타입을 직접 조회

### 해결방법2. 프록시 벗기기
- `hibernate`가 제공하는 프록시에서 원본 엔티티를 찾는 기능을 사용하기
- 프록시에서 원본 엔티티를 직접 꺼내기 때문에 프록시와 원본 엔티티의 동일성 비교가 실패한다.
> 원본 엔티티가 꼭 필요한 곳에서만 잠깐 사용하고, 다른 곳에서는 사용되지 않도록 하는 것이 중요하다.

### 해결방법3. 기능을 위한 별도의 인터페이스 제공
- 인터페이스를 제공하고 각각의 클래스가 자신에 맞는 기능을 구현한다.

### 해결방법4. Visitor 패턴 사용
- 자식 클래스는 부모 클래스의 메서드(accept)를 구현한다.
    - 파라미터로 넘어온 Visitor의 visit 메서드를 호출하면서 자신을 파라미터로 넘긴다.
    - 실제 로직 처리를 visitor에 위임한다.
- 새로운 기능이 필요할 때 Visitor에 추가한다.

- 장점
    - 프록시의 걱정 없이 안전하게 원본 엔티티에 접근
    - `instanceof`와 타입 캐스팅 없이 코드 구현
- 단점
    - 너무 복잡하고 더블 디스패치를 사용하므로 이해하기 어렵다
    - 객체 구조가 변경되면 모든 Visitor를 수정해야 한다.

# 15.4 성능 최적화
## N+1 문제
- JPQL을 실행할 때 즉시로딩에서 N+1 문제가 발생할 수 있다.
- JPQL을 실행할 때 지연로딩시 N+1 문제가 발생하지 않는다. 하지만 여러 엔티티를 한번에 조회할 경우 연관 엔티티를 초기화하는 수만큼 쿼리를 불러와 N+1문제가 발생한다.

### 해결방법1:  `fetch join` 사용
- sql join을 사용해서 연관된 엔티티를 함께 조회
> 일대다 조인을 했으므로 결과가 늘어나서 중복된 결과가 있을 수 있다.
> JPQL의 `Distinct`를 사용해서 중복을 제거하자.

### 해결방법2. `@BatchSize`
- 연관된 엔티티를 조회할 때 지정한 size만큼 SQL의 IN 절을 사용해서 조회한다.

### 해결방법3: `@Fetch(FetchMode.SUBSELECT)`
- 연관된 엔티티를 조회할 때 서브 쿼리를 사용해서 N+1문제를 해결한다.

### N+1 정리
- 즉시 로딩은 사용하지 말고 지연 로딩만 사용하자
- 즉시 로딩은 N+1 문제는 물론이고 비즈니스 로직에 따라 필요하지 않은 엔티티를 로딩하는 상황이 자주 발생한다.
- 즉시 로딩은 성능 최적화가 어렵다.
> 모두 지연 로딩으로 설정하고 성능 최적화가 꼭 필요한 곳에만 JPQL의 `Fetch Join`을 사용하자.
- 글로벌 Fetch 전략
    - `@OneToOne`, `@ManyToOne` : 기본 페치 전략은 즉시 로딩
    - `@OneToMany,` `@ManyToMany`: 기본 페치 전략은 지연 로딩
> 기본값이 즉시 로딩인 `@OneToOne`과 `@ManyToOne`은 `fetch=FetchType.LAZY`로 설정해서 지연 로딩 전략을 사용하자.

📌
Q1.  Visitor 패턴에서 자식 클래스에서 구현한 accept는 다형성을 이용하기 위한 것인가? (672p)

Q2. 더블 디스패치란? (675p)

Q3. fetch join에서 일대다 조인을 할 경우 중복된 결과가 나타날 수 있는 이유? (679p)

Q4. batchsize와 subselect는 둘 다 in 쿼리를 사용하는데, subselect는 연관된 엔티티가 몇개여도 하나의 서브 쿼리로 조회하는지? (681p)

### [0809] 682~702
### 읽기 전용 쿼리의 성능 최적화
- 엔티티가 영속성 컨텍스트에 관리되면 1차 캐시부터 변경 감지까지 얻을 수 있는 혜택이 많다.
- 영속성 컨텍스트는 변경 감지를 위해 스냅샷 인스턴스를 보관하므로 많은 메모리를 사용한다.

- **1. 스칼라 타입으로 조회**
  엔티티가 아닌 스칼라 타입으로 모든 필드를 조회한다.
  스칼라 타입은 영속성 컨텍스트가 결과를 관리하지 않는다.

- **2. 읽기 전용 쿼리 힌트 사용**
  hibernate 전용 힌트인 readOnly를 사용하면 엔티티를 읽기 전용으로 조회할 수 있다.
  읽기 전용이므로 영속성 컨텍스트는 스냅샷을 보관하지 않는다. (메모리 사용량 최적화)
> 엔티티를 수정해도 db에 반영되지 않는다.

- **3. 읽기 전용 트랜잭션 사용**
  트랜잭션을 읽기 전용 모드(@Transactional(readOnly=true))로 설정하면 hibernate 세션의 flush 모드를 MANUAL한다. 이를 통해 강제로 flush를 호출하지 않는 한 flush가 일어나지 않는다.
> flush를 호출할 때 스냅샷 비교 등 무거운 로직을 호출하지 않기 때문에 성능이 향상된다.

- **4. 트랜잭션 밖에서 읽기**
  트랜잭션 없이 엔티티를 조회한다.
  `@Transactional(propagation=Propagation.NOT_SUPPORTED)`

- 읽기 전용 데이터 조회 - 스칼라 타입 조회, 읽기 전용 쿼리 힌트 사용
> 엔티티를 읽기 전용으로 조회해서 메모리 절약
- 플러시 호출을 막아 속도 최적화 - 읽기 전용 트랜잭션 사용, 트랜잭션 밖에서 읽기
> flush를 작동하지 않도록 해서 성능 향상
=> ***읽기 전용 트랜잭션과 읽기 전용 쿼리 힌트를 동시에 사용하는 것이 효과적이다.***

### 배치 처리
- 수백만 건의 데이터를 배치 처리해야할 경우 영속성 컨텍스트에 아주 많은 엔티티가 쌓여 메모리 부족 오류가 발생한다.
- 따라서 적절한 단위로 영속성 컨텍스트를 초기화해야한다.
- 2차 캐시를 사용하고 있다면 2차 캐시에 엔티티를 보관하지 않도록 주의해야한다.

- 수정 배치 처리
    - 페이징 처리 : 데이터 베이스 페이징 기능 사용
      페이지 단위마다 영속성 컨텍스트를 flush하고 초기화
    - 커서 : 데이터베이스가 지원하는 커서 기능 사용
      scroll(jdbc 커서)는 hibernate 전용 기능이므로 em.uwrap()을 사용해 hibernate 세션을 구하고, 쿼리를 조회하면서 scroll() 메서드로 ScrollableResults 객체를 반환받는다. next()를 호출하면 엔티티를 하나씩 조회할 수 있다.

- hibernate 무상태 세션 사용
  무상태 세션 : 영속성 컨텍스트를 만들지 않고 2차 캐시도 사용하지 않는다.
  영속성 컨텍스트가 없으며 엔티티를 수정하려면 무상태 세션이 제공하는 update() 메서드를 직접 호출해야한다.


### SQL 쿼리 힌트 사용
- JPA는 데이터베이스 SQL 힌트 기능을 제공하지 않으므로 hibernate를 직접 사용해야한다.
- addQueryHint() 메서드를 사용한다.

### 트랜잭션을 지원하는 쓰기 지연과 성능 최적화
네트워크 호출 한번은 단순히 메서드를 수만번 호출하는 것보다 큰 비용이 든다.
최적화하려면 SQL을 모아서 한번에 db로 보내면 된다.
> JDBC가 제공하는 SQL 배치 기능을 사용해서 SQL을 모아서 db에 한번에 보낼 수 있다.
> batchsize의 값을 지정할 수 있다.

- 트랜잭션을 지원하는 쓰기 지연과 변경 감지 기능 덕분에 **데이터베이스 row에 락이 걸리는 시간을 최소화**할 수 있다.
  JPA를 사용하지 않고 SQL을 직접 다루면 쿼리를 실행하면서 db 테이블 row에 락을 걸고, 커밋을 호출할 때까지 유지한다.
  JPA는 commit() 호출시 flush를 호출하고 db에 수정 쿼리를 보낸 후 커밋한다.

# 16. 트랜잭션과 락, 2차 캐시
# 16.1 트랜잭션과 락
- 트랜잭션 ACID
  원자성, 일관성, 격리성, 지속성
- 트랜잭션 격리 수준
  `READ UNCOMMITED` -> `DIRTY READ` 문제
  `READ COMMITED` -> `NON-REPEATABLE READ` 문제
  `REPEATABLE READ` -> `PHANTOM READ` 문제
  `SERIALIZABLE`

## 낙관적 락과 비관적 락
- JPA의 영속성 컨텍스트(1차 캐시)를 적절히 활용하면 READ COMMITED 격리 수준이어도 애플리케이션 레벨에서 반복가능한 읽기가 가능하다.
- JPA는 트랜잭션 격리수준을 READ COMMITED으로 가정한다. 더 높은 격리 수준이 필요하면 낙관적 락과 비관적 락 중 하나를 사용하면 된다.
- 낙관적 락 : 트랜잭션 대부분은 충돌이 발생하지 않는다고 가정, JPA가 제공하는 버전 관리 기능을 사용한다.
> 트랜잭션을 커밋하기 전까지는 트랜잭션의 충돌을 알 수 없다.
- 비관적 락 : 트랜잭션의 충돌이 발생한다고 가정하고 락을 걸고 보는 방법, 데이터베이스가 제공하는 락 기능 사용

- 두번의 갱신 분실 문제
  데이터베이스 트랜잭션 범위를 넘어선다.

- 해결 방법
1. 마지막 커밋만 인정하기
2. 최초 커밋만 인정하기
3. 충돌하는 갱신 내용 병합하기

### @Version : 버전 관리용 필드
**엔티티를 수정할 때마다 버전이 하나씩 자동으로 증가한다.**
엔티티를 수정할 때 조회 시점의 버전과 수정 시점의 버전이 다르면 예외가 발생한다.
> 버전 정보를 사용하면 최초 커밋만 인정하기가 적용된다.

- JPA가 버전 정보를 비교하는 방법
  엔티티를 수정하고 트랜잭션을 커밋하면 영속성 컨텍스트를 flush하면서 update 쿼리를 실행한다.
  버전을 사용하는 엔티티면 검색 조건에 엔티티의 버전 정보를 추가한다.
  db 버전과 엔티티버전이 같으면 동시에 버전을 증가시키고, 다르면 예외를 발생시킨다.

> 임베디드 타입과 값 타입 컬렉션은 논리적인 개념 상 엔티티의 값이므로 수정하면 엔티티의 버전이 증가한다.
> 연관관계 필드는 외래키를 관리하는 연관관계의 주인 필드를 수정할 때만 버전이 증가한다.

> @Version으로 추가한 버전 관리 필드는 JPA가 직접 관리하므로 개발자가 임의로 수정하면 안된다.

> 벌크 연산은 버전을 무시한다.

### JPA 락 사용
JPA를 사용할 때 추천하는 전략은 READ COMMITED 격리 수준 + 낙관적 버전 관리(두번의 갱신 내역 분실 문제 예방)

### JPA 낙관적 락
- 버전(@Version)을 사용한다.
- 낙관적 락은 트랜잭션을 커밋하는 시점에 충돌을 알 수 있다.
> 락 옵션 없이 @Version만 있어도 낙관적 락이 적용된다.

- **NONE**
  락 옵션을 적용하지 않아도 엔티티에 @Version이 적용된 필드만 있으면 낙관적 락이 적용된다.
  용도) 조회한 엔티티를 수정할 때 다른 트랜잭션에 의해 변경되지 않아야 한다. (조회~수정 시점 보장)
  동작) 엔티티를 수정할 때 버전을 체크하면서 버전을 증가한다.
  이점) 두번의 갱신 분실 문제를 예방한다.

📌

Q1. 읽기 전용 쿼리 힌트를 사용하면 스냅샷을 보관하지 않으므로 해당 엔티티를 읽기 전용으로 계속 호출하면 매번 쿼리가 나가는지(682p)

Q2. 트랜잭션 밖에서 읽기에서 트랜잭션 없이 엔티티 조회가 가능한 일인지(683p)

Q3. 배치 처리시에 2차 캐시에 엔티티를 보관하지 않도록 주의해야하는 이유, 2차 캐시란?(684p)

Q4.JDBC 커서인 scroll은 무엇일까? (686p)

Q5. hibernate 세션을 조회하는 것이(em.unwrap) 하이버네이트를 직접 사용하는 것과 같은지 (688p)

Q6. 커밋된 읽기를 선택하면 다른 트랜잭션은 락이 풀릴때까지 대기한다고 하는데, 그 전의 커밋된 데이터를 읽는것이 아닌지? (691p)

Q7. 애플리케이션 서버를 증설해서 트랜잭션이 증가할 수록 더 많은 데이터베이스 락이 걸리는 이유(691p)

### [0810] 703~723
**OPTIMISITC**
- 엔티티를 조회하거나 수정할때 버전을 체크한다.
- 한번 조회한 엔티티는 트랜잭션을 종료할 때까지 다른 트랜잭션에서 변경되지 않음을 보장한다.
- DIRTY READ와 NON-REPEATABLE READ를 방지한다.

**OPTIMISITC_FORCE_INCREMENT**
- 낙관적 락을 사용하면서 버전 정보를 강제로 증가한다
- 트랜잭션을 커밋할 때 update 쿼리를 사용해서 버전 정보를 강제로 증가시킨다.
- 엔티티 수정시 해당 옵션을 사용하면 2번의 버전 증가가 나타날 수 있다.
- Aggregate Root를 관리하는 엔티티를 수정했을 때 Aggregate Root 버전을 강제로 증가시킬 수 있다.

### JPA 비관적 락
- db 트랜잭션 메커니즘에 의존하는 방법이다.
- sql 쿼리에 select for update 구문을 사용하면서 시작하고, 주로 PESSIMISITC_WRITE 모드를 사용한다.
- 엔티티가 아닌 스칼라 타입을 조회할 때도 사용할 수 있다.
- 데이터를 수정하는 즉시 트랜잭션 충돌을 감지할 수 있다.

PESSIMISITC_WRITE
- 데이터베이스에 쓰기 락을 건다.
- `db select for update`를 사용해서 락을 건다.
- `NON-REPEATABLE READ`을 방지한다. 락이 걸린 로우는 다른 트랜잭션이 수정할 수 없다.

PESSIMISITC_READ
- 데이터를 반복 읽기만 하고 수정하지 않는 용도로 락을 걸 때 사용한다.
- 일반적으로 잘 사용하지 않는다.

PESSIMISITIC_FORCE_INCREMENT
- 버전 정보를 유일하게 사용한다. 비관적 락이지만 버전 정보를 강제로 증가시킨다.
- nowait를 지원하는 데이터베이스에 대해서 for update nowait 옵션을 적용한다.

### 비관적 락과 타임아웃
- 비관적 락을 사용하면 락을 획득할 때까지 트랜잭션이 대기한다.
- 10초간 대기해서 응답이 없으면 LockTimeoutException 예외가 발생한다.

# 16.2 2차 캐시
## 1차 캐시와 2차 캐시
- 네트워크를 통해 db에 접근하는 시간 비용은 애플리케이션 서버에서 내부 메모리에 접근하는 시간 비용보다 비싸다.
- 조회한 데이터를 메모리에 캐시해서 데이터베이스 접근 횟수를 줄이면 애플리케이션 성능을 개선할 수 있다.

### 1차 캐시: 영속성 컨텍스트 내부에 엔티티를 보관하는 장소
- 엔티티 매니저로 조회하거나 변경하는 모든 엔티티
> 트랜잭션을 커밋하거나 flush를 호출하면 2차 캐시에 있는 엔티티 변경 내역을 데이터베이스에 동기화한다.
- 일반적인 웹 애플리케이션 환경은 트랜잭션을 시작하고 종료할 때까지만 1차 캐시가 유효하다.
- OSIV를 사용해도 클라이언트의 요청이 들어올 때부터 끝날 때까지만 1차 캐시가 유효하다.
> 영속성 컨텍스트 자체가 사실상 1차 캐시이다.
- 특징
    - 1차 캐시는 같은 엔티티가 있으면 해당 엔티티를 그대로 반환한다. 1차 캐시는 객체 동일성을 보장한다.
    - 1차 캐시는 영속성 컨텍스트 범위의 캐시이다.

### 2차 캐시: 애플리케이션 범위의 캐시
- 애플리케이션을 종료할 때까지 캐시가 유지된다.
- 엔티티 매니저를 통해 데이터를 조회할 때 우선 2차 캐시에서 찾고, 없으면 데이터베이스에서 찾는다.
    - 2차 캐시를 적절히 활용하면 데이터베이스 조회 횟수를 획기적으로 줄일 수 있다.
- 2차 캐시는 동시성을 극대화하기 위해 캐시한 객체의 복사본을 반환한다(락 방지)
- hibernate를 포함한 대부분의 JPA 구현체들은 2차 캐시를 지원한다.
- 특징
    - 영속성 유닛 범위의 캐시이다.
    - 2차 캐시는 데이터베이스 기본 키를 기준으로 캐시하지만 영속성 컨텍스트가 다를 경우 객체 동일성을 보장하지 않는다.

## JPA 2차 캐시 기능

### 캐시 모드 설정
`@Cacheable`로 설정하고, 기본값은 true이다.

- `SharedCacheMode`
  `ALL` : 모든 엔티티 캐시
  `NONE` : 캐시를 사용하지 않음
  `ENABLE_SELECTIVE` : Cacheable(true)로 설정된 엔티티만 캐시 적용
  `DISABLE_SELECTIVE` : 모든 엔티티를 캐시하는데 Cacheable(false)로 명시된 엔티티는 캐시하지 않음
  `UNSPECIFIED` : JPA 구현체가 정의한 설정에 따름

### 캐시 조회, 저장 방식 설정
- 캐시 조회 모드 (`CacheRetrieveMode`)
  `USE` : 캐시에서 조회 (기본값)
  `BYPASS` : 캐시를 무시하고 데이터베이스에 직접 접근

- 캐시 보관 모드 (`CacheStoreMode`)
  `USE` : 조회한 데이터를 캐시에 저장
  `BYPASS` : 캐시에 저장하지 않음
  `REFRESH`: USE 전략에 추가로 데이터베이스에 조회한 엔티티를 최신 상태로 다시 캐시

### JPA 캐시 관리 API
Cache 인터페이스를 사용하여 관리한다.
contains, evict, evictAll, unwrap

### 하이버네이트와 EHCACHE 적용
1. 엔티티 캐시 : 엔티티 단위로 캐시한다.
   식별자로 엔티티를 조회하거나 컬렉션이 아닌 연관된 엔티티를 로딩할 때 사용한다.
2. 컬렉션 캐시: 엔티티와 연관된 컬렉션을 캐시한다.
   컬렉션이 엔티티를 담고 있으면 식별자 값만 캐시한다.
3. 쿼리 캐시 : 쿼리와 파라미터 정보를 키로 사용해서 캐시한다.
   결과가 엔티티면 식별자 값만 캐시한다.

ehcache.xml : 캐시 정책 정의하는 설정 파일
persistence.xml 에 캐시 정보 추가
- `use_second_level_cache` : 2차 캐시 활성화
- `use_query_cache` : 쿼리 캐시를 활성화
- `factory_class` : 2차 캐시를 처리할 클래스 지정
- `generate_statistics` : 통계정보 출력, 캐시 적용 여부 확인 가능

### 엔티티 캐시와 컬렉션 캐시
`@Cache` : 세밀한 캐시 설정 가능
- `usage` : 캐시 동시성 전략 설정
- `region` : 캐시 지역 설정
- `include` : 연관 객체를 캐시에 포함할지 선택

`**CacheConcurrencyStrategy**` ( 캐시 동시성 전략 설정)
- `NONE` : 캐시를 설정하지 않는다.
- `READ_ONLY` : 읽기 전용으로 설정한다.
- `NONSTRICT_READ_WRITE` : 엄격하지 않은 읽고 쓰기 전략
- `READ_WRITE` : 읽고 쓰기가 가능하고 READ COMMITTED 정도의 격리 수준 보장
- `TRANSACTIONAL` : 컨테이너 관리 환경, REPEATABLE_READ 정도의 격리 수준 보장

캐시 영역
- 엔티티 캐시 영역 : `ParentMember`
- 컬렉션 캐시 영역 : `ParentMember.childMembers`

**쿼리 캐시**
쿼리와 파라미터 정보를 키로 사용해서 쿼리 결과를 캐시하는 방법
use_query_cache 옵션 true로 설정 후 cacheable을 true로 설정

**쿼리 캐시 영역**
- `StandardQueryCache` : 쿼리 캐시를 저장하는 영역
- `UpdateTimestmpsCache` : 쿼리 대상 테이블의 가장 최근 변경 시간 저장

- 쿼리 캐시는 캐시한 데이터 영역을 최신 데이터로 유지하려고 쿼리 캐시를 실행하는 시간과 쿼리 캐시가 사용하는 테이블들이 가장 최근에 변경된 시간을 비교한다.
- 쿼리 캐시를 적용하고 난 후에 쿼리 캐시가 사용하는 테이블에 조금이라도 변경이 있으면 데이터베이스에서 데이터를 읽어와서 쿼리 결과를 캐시한다.
> 쿼리 캐시를 활용하면 극적인 성능 향상이 있지만 빈번하게 변경이 있는 테이블에 사용하면 오히려 성능이 더 저하된다.

### 쿼리 캐시와 컬렉션 캐시의 주의점
- 엔티티 캐시를 사용해서 엔티티를 캐시하면 엔티티 정보를 모두 캐시하지만 쿼리 캐시와 컬렉션 캐시는 결과 집합의 식별자 값만 캐시한다.
- 식별자 값을 하나씩 엔티티 캐시에서 조회해서 실제 엔티티를 찾아야 한다.
- 쿼리 캐시나 컬렉션 캐시를 사용하면 결과 대상 엔티티에는 꼭 엔티티 캐시를 적용해야 한다.

## 정리
- 트랜잭션의 격리 수준은 4단계가 있다. 격리 수준이 낮을수록 동시성은 증가하지만 격리 수준에 따른 문제가 발생한다.
- 영속성 컨텍스트는 데이터베이스 트랜잭션이 `READ COMMITED` 격리 수준이어도 애플리케이션 레벨에서 `REPEATABLE READ`를 제공한다.
- JPA는 낙관적 락과 비관적 락을 지원한다.
    - **낙관적 락 **: 애플리케이션이 지원하는 락
    - **비관적 락** : 데이터베이스 트랜잭션 락 메커니즘에 의존
- 2차 캐시를 사용하면 애플리케이션 조회 성능을 극적으로 끌어올릴 수 있다.

📌

Q1. 비관적 락은 sql 쿼리에 `select for update `구문을 사용하면서 시작하고 버전 정보는 사용하지 않는다는 의미(705p)

Q2. `PESSIMISITC_FORCE_INCREMENT` : hibernate는 nowait를 지원하는 데이터베이스에 대해 f`or update nowait `옵션을 적용한다는 말의 의미? (706p)

Q3. 2차 캐시는 영속성 유닛 범위의 캐시라고 하는데, 영속성 유닛이란? (710p)

Q4. `EHCACHE`란? (715p)

Q5. 엔티티 캐시와 컬렉션 캐시, 쿼리 캐시 예시 (715p)

# 📌 질의응답
## [0806]

### Q1.  `Visitor` 패턴에서 자식 클래스에서 구현한 `accept`는 다형성을 이용하기 위한 것인가? (672p)
- `accept`는 다형성을 활용한다.
- `Item item = itemRepository.findById(id);`으로 조회하더라도, 실제 엔티티가 `Item`의 하위 클래스의 객체일 경우 **실제 객체 타입의 accept가 호출된다. (동적 바인딩)**
- 프록시 객체는 실제 메서드가 호출될 때 초기화되므로, **accept 호출시 프록시는 실제 엔티티 객체로 초기화**된다.

### Q2. 더블 디스패치란? (675p)
- 두번의 메서드 호출을 통해 실행할 메서드를 결정한다.
    - `accept` -> `visit`

### Q3. `fetch join`에서 일대다 조인을 할 경우 중복된 결과가 나타날 수 있는 이유? (679p)
- 일대다 관계에서 다의 데이터 수만큼 일쪽 데이터가 중복되어 조회될 수 있다.
- ex) Order와 OrderItem은 1:다
    - `SELECT o FROM Order o JOIN FETCH o.orderItems`
    - 결과
        - Order1, OrderItem1
        - Order1, OrderItem2
    - Order가 OrderItem의 개수만큼 중복되어 나타난다.
    - `DISTINCT`를 사용하여 중복을 제거할 수 있다.

### Q4. `batchsize`와 `subselect`는 둘 다 `in` 쿼리를 사용하는데, `subselect`는 연관된 엔티티가 몇개여도 하나의 서브 쿼리로 조회하는지? (681p)
- 맞다.
- 둘 다 in 쿼리를 사용하지만, `@SubSelect`는 연관된 엔티티 수와 관계없이 하나의 서브쿼리로 모든 데이터를 조회한다.
    - `@SubSelect` 는 모든 데이터를 한번에 로드하므로 메모리 사용량이 높다.

## [0809]
### Q1. 읽기 전용 쿼리 힌트를 사용하면 스냅샷을 보관하지 않으므로 해당 엔티티를 읽기 전용으로 계속 호출하면 매번 쿼리가 나가는지(682p)
- 맞다. 쿼리 실행은 맞지만 **영속성 컨텍스트에서 엔티티를 가져올 수 있다.**
- 스냅샷을 보관하지 않아서 변경 감지를 비활성화하여 메모리 사용을 줄인다.
    - db에 쿼리를 매번 보내도 영속성 컨텍스트의 1차 캐시는 여전히 동작하므로 db까지 조회하지 않고 영속성 컨텍스트에서 엔티티를 가져온다.
    - **스냅샷이 없으므로 변경 감지는 수행되지 않는다.**

### Q2. 트랜잭션 밖에서 읽기에서 트랜잭션 없이 엔티티 조회가 가능한 일인지(683p)
- JPA는 **트랜잭션 없이도 데이터를 조회**할 수 있도록 한다.
    - `EntityManager`를 사용하여 직접 엔티티를 조회(`find`)한다.
    - 조회만 가능하고, 엔티티를 수정할 수는 없다.
- 트랜잭션 밖에서 수행되므로 `ACID` 속성을 보장받지 못한다.

### Q3. 배치 처리시에 2차 캐시에 엔티티를 보관하지 않도록 주의해야하는 이유, 2차 캐시란?(684p)
- **2차 캐시**는 **애플리케이션 전체에서 공유하는 캐시**이다.
- 배치 처리시 대량의 데이터를 2차 캐시에 보관하면 `메모리 부족 문제`가 발생할 수 있다.

### Q4.JDBC 커서인 `scroll`은 무엇일까? (686p)
- 데이터베이스 결과를 앞뒤로 자유롭게 이동할 수 있는 커서 기능이다.
- Scroll 타입
    - `FORWARD_ONLY`: 앞으로만 이동 가능 (기본값)
    - `SCROLL_INSENSITIVE`: 양방향 이동 가능, 변경사항 감지 안 함
    - `SCROLL_SENSITIVE`: 양방향 이동 가능, 변경사항 감지 함
```java
Session session = em.unwrap(Session.class);
ScrollableResults scroll = session.createQuery("from User")
    .setCacheMode(CacheMode.IGNORE)
    .scroll(ScrollMode.FORWARD_ONLY);

while (scroll.next()) {
    User user = (User) scroll.get(0);
}
scroll.close();
```

### Q5. `hibernate` 세션을 조회하는 것이(`em.unwrap`) 하이버네이트를 직접 사용하는 것과 같은지 (688p)
- 맞다.
```java
Session session = em.unwrap(Session.class);
```
- `em.unwrap`은 JPA의 구현체(여기서의 Hibernate)의 네이티브 api를 사용할 수 있게 해준다.

### Q6. 커밋된 읽기를 선택하면 다른 트랜잭션은 락이 풀릴때까지 대기한다고 하는데, 그 전의 커밋된 데이터를 읽는것이 아닌지? (691p)
- 커밋된 읽기는 다른 트랜잭션의 커밋된 데이터만 읽을 수 있다.
    - 커밋되지 않은 변경사항은 다른 트랜잭션에 보이지 않는다.
- 커밋된 읽기 수준에서는 읽기 작업은 락을 획득하지 않지만, 쓰기 작업은 다른 트랜잭션의 쓰기 락이 해제될 때까지 대기한다.

### Q7. 애플리케이션 서버를 증설해서 트랜잭션이 증가할 수록 더 많은 데이터베이스 락이 걸리는 이유(691p)
- 동시에 더 많은 트랜잭션이 실행되므로, 동일한 데이터에 접근하는 빈도가 높아져 락이 더 자주 발생한다.

## [0810]
### Q1. 비관적 락은 sql 쿼리에 `select for update `구문을 사용하면서 시작하고 버전 정보는 사용하지 않는다는 의미(705p)
- **비관적 락**
    - 트랜잭션 충돌이 빈번하게 일어날 것이라고 가정한다.
    - 데이터를 읽는 시점에 다른 트랜잭션이 해당 데이터를 변경하지 못하도록 (물리적으로 데이터베이스에서) 락을 거는 방식
- `select for update `
    - 비관적 락을 구현하는 방식으로, 선택된 행에 배타적 락을 설정한다.
```sql
SELECT * FROM users WHERE id = 1 FOR UPDATE;
```
- id가 1인 사용자 데이터를 조회하면서 동시에 그 행에 락을 건다.
- 해당 데이터를 읽고 곧 업데이트할 것이니 다른 트랜잭션이 건드리지 말라고 알리는 것과 같다.
- 다른 트랜잭션이 해당 데이터를 읽거나 수정하는 것을 방지한다.

- JPA
```java
@Lock(LockModeType.PESSIMISTIC_WRITE)
@Query("SELECT u FROM User u WHERE u.id = :id")
User findByIdWithPessimisticLock(@Param("id") Long id);
```
- 데이터베이스 수준의 락을 사용하므로 버전 정보는 사용하지 않는다.

- **낙관적 락**
    - 동시에 여러 트랜잭션이 같은 데이터를 수정하려는 충돌이 거의 발생하지 않을 것이라고 낙관적으로 가정한다.
    - 실제로(물리적으로) 데이터를 잠그지 않고, **데이터 수정시 충돌을 감지하고 처리**한다.
- **버전 정보를 사용**한다.
    - 버전 정보를 사용하여 데이터의 변경을 추적한다.
    - 엔티티에 버전 칼럼을 추가하고, 데이터가 수정될때마다 버전을 증가시킨다.
    - 수정시 현재 버전과 데이터베이스의 버전을 비교하여 충돌을 감지한다.
```java
@Entity
public class User {
    @Id
    private Long id;
    
    private String name;
    
    @Version
    private Long version;
}
```

- JPA
```java
@Lock(LockModeType.OPTIMISTIC)
@Query("SELECT u FROM User u WHERE u.id = :id")
User findByIdWithOptimisticLock(@Param("id") Long id);
```

### Q2. `PESSIMISITC_FORCE_INCREMENT` : hibernate는 nowait를 지원하는 데이터베이스에 대해 `for update nowait `옵션을 적용한다는 말의 의미? (706p)
- `PESSIMISITC_FORCE_INCREMENT`
    - 비관적 락을 설정하면서 동시에 버전을 강제로 증가시킨다.
- `for update nowait`는 락을 즉시 획득할 수 없으면 바로 예외를 발생시킨다.
    - 트랜잭션이 불필요하게 대기하는 상황을 방지한다.

### Q3. 2차 캐시는 영속성 유닛 범위의 캐시라고 하는데, 영속성 유닛이란? (710p)
- 영속성 유닛이란 **연관된 엔티티 클래스들의 집합**을 정의하는 설정 단위이다.
    - 주로 `persistence.xml` 파일에 정의된다.
- 같은 영속성 유닛 내의 모든 엔티티 매니저가 2차 캐시를 공유한다.

### Q4. `EHCACHE`란? (715p)
- java 기반 오픈소스 분산 캐시 라이브러리이다.
- Hibernate의 2차 캐시 제공자로 사용된다.

### Q5. 엔티티 캐시와 컬렉션 캐시, 쿼리 캐시 예시 (715p)
- **엔티티 캐시**: `@Entity` 클래스의 인스턴스 캐싱
```java
@Entity
@Cache(usage = CacheConcurrencyStrategy.READ_WRITE)
public class User { ... }
```
- **컬렉션 캐시** : `@OneToMany`, `@ManyToMany` 등의 컬렉션 캐싱
```java
@OneToMany
@Cache(usage = CacheConcurrencyStrategy.READ_WRITE)
private List<Order> orders;
```
- **쿼리 캐시**: 특정 쿼리 결과를 캐싱
```java
Query query = session.createQuery("from User")
    .setCacheable(true);
```

