## 1주차

📌 **90 ~ 110** : 영속상태의 엔티티의 데이터만 변경했을 때 데이터베이스에 반영되는 이유는 다음과 같다.
JPA는 엔티티를 영속성 컨텍스트에 보관할 때 스냅샷을 저장해두는데, flush() 시점에 스냅샷과 엔티티를 비교하여 변경된 부분을 찾아 변경된 부분이 있다면 수정 쿼리를 쓰기 지연 저장소에 보내고 트랜잭션 커밋 시 SQL문을 데이터베이스에 보낸다.

📌 **110 ~ 130** : 준영속 상태에서는 영속성 컨텍스트가 관리하지 않으므로 1차캐시, 쓰기 지연, 변경 감지, 지연 로딩 등의 기능이 동작하지 않는다.
따라서 준영속 상태를 다시 영속 상태로 변경하려면 merge()를 사용하면 되는데 중요한 점은 준영속 상태의 엔티티를 받고 `새로운 영속 상태 엔티티`를 반환한다.
따라서
```java
Member mergeMember = em2.merge(member)  // 새로운 영속 상태 엔티티 반환하기 때문에 
member = em2.merge(member)  // 아래 코드로 사용하는 것이 좋다.
```

📌 **131 ~ 150** : `기본키`를 설정할 때 `자연키`보다는 `대리키`를 권장하는 이유는 뭘까?
`전화번호`로 예를 들면 자연키인 전화번호는 **유일**하여 기본키가 될 수 있지만 **null 일 수도 있고 변경될 수도 있어** 적절하지 않다. 하지만 `주민등록번호`는** null 일 수도 없고 변경될 일도 없어서** 기본키로 아주 적절해 보인다.
그렇다면 **회원 테이블에 주민등록번호가 기본키로 설정**되어있다고 가정해보자. 회원과 관련된 수많은 테이블에서 `조인`을 위해 **주민등록번호가 외래 키**로 잡혀있을 것이다. 여기서 문제가 발생할 수 있는데 만약 **해당 서비스에서 더이상 주민등록번호를 저장하면 안되는 상황이 발생**한다면 데이터베이스의 테이블과 수많은 어플리케이션 로직들을 **수정**해야할것이다.
따라서 데이터베이스를 처음 설계할 때 **비즈니스와 관련 없는** `대리 키`를 사용하는 것이 현명한 방법일것이다.

📌 **151~173**
객체는 `참조`를 사용해서 관계를 맺고, 테이블은 `외래 키`를 사용해서 관계를 맺는다.
그렇다면 **객체 연관관계와 테이블 연관관계를 어떻게 매핑**해야할까?

핵심은 **3가지**이다.
1. **방향** : 단방향과 양방향
2. **다중성**: 다대일(N:1) / 일대다(1:N) / 일대일(1:1) / 다대다(N:N)
3. **연관관계 주인** : 양방향 설정 시 연관관계 주인을 설정해야함

📌 **174~195**
**양방향 연관관계**를 설정할 때의 주의할점은 무엇인가?
양방향 연관관계를 설정하고 연관관계의 주인이 아닌곳만 값을 입력하면 DB에 값이 정상적으로 저장되지 않을 것이다. 때문에 **연관관계 주인에 값을 저장**해주는 것을 잊지 말자.
여기서 중요한 점은 `객체` 관점에서 봤을 때 사실 **양쪽 방향**에 모두 값을 입력해주는 것이 가장 안전하다고 한다.

📌 **196~215**
`다대일` `일대다` 다중성을 공부하면서 다대일 `단방향 관계`,`양방향 관계`는 **다 쪽에 항상 외래키**를 가지고 있고 따라서 **연관관계 주인**도 설정하는데 어려움이 없었다.
하지만 **일대다 단방향 관계**에서는 일대다 관계에서도 `외래키`를 항상 다쪽에 있지만 **다쪽에 외래키를 매핑할 수 있는 참조 필드가 없다**. 그러면 **반대편 테이블의 외래키를 관리**하는 특이한 모습이 발생한다.

- 정리하자면 일대다 단방향 매핑의 단점은 매핑한 객체가 관리하는 외래 키가 다른 테이블에 있다는 점이다.
- 따라서 일대다 단방향매핑보다는 다대일 양방향 매핑을 사용하는 것을 권장한다.

📌 **216~241**
다대다 관계에서는 연결 테이블을 매핑하는 연결 엔티티를 만드는 것이 좋다.
주의할 점은 이러한 연결 엔티티를 만들 때 기본키가 복합키로 이루어질 수 있는데 JPA에서 복합키를 사용하려면 별도의 식별자 클래스를 만들어 복잡해지고 ORM 매핑에서 처리해야 할 일들이 많아진다.
따라서 복합 키를 사용하지 않고 간단히 다대다 관계를 구성하는 방법이 있는데 바로 새로운 기본 키를 사용하는 것이다. 다대다를 연결해주는 테이블에 새로운 기본 키를 생성하면 복합 키를 사용하는 것보다 매핑이 단순하고 이해하기 쉬워진다.

다음은 다대다 관계에서 연결해주는 테이블에 복합키를 사용하여 조회하는 코드와 기본키를 사용해서 조회하는 코드의 차이점이다.

// 복합 키 사용 조회
```java
public void find(){

// 복합 키의 기본 키 값 생성
MemberProductId memberProductId = new MemberProductId();
memberProductId.setMemeber("member1");
memberProductId.setProduct("productA");

MemberProduct memberProduct = em.find(MemberProduct.class,memberProductId);

Member member = memberProduct.getMember();
Product product = memberProduct.getProduct();

.... 조회 코드
}
```

// 기본 키 사용 조회
```java
public void find(){
// 기본 키 
Long orderId = 1L;
Order order = em.find(Order.class,orderId);

Member member = order.getMember();
Product product = order.getProduct();

.... 조회 코드
}
```