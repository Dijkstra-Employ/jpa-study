### [0801] 559~577
### 도메인 클래스 컨버터 기능
- HTTP 파라미터로 넘어온 엔티티의 id로 엔티티 객체를 찾아서 바인딩해준다.
- 해당 엔티티와 관련된 레포지토리를 사용해서 엔티티를 찾는다.
### 페이징과 정렬
- 페이징 기능 : `PageableHandlerMethodArgumentResolver`
    - 파라미터로 Pageable을 받는다. (인터페이스이고 실제는 `PageRequest` 객체가 생성된다.)
    - `page` : 현재 페이지, 0부터 시작
    - `size` : 한 페이지에 노출할 데이터 건수
    - `sort` : 정렬 조건 정의
    - 사용할 페이징 정보가 둘 이상이면 접두사를 사용하여 구분한다. `@Qualifier`를 이용하며, 점두사명_로 구분한다.
    - `Pageable`의 기본값은 page=0, size=20이다.
- 정렬 기능 : `SortHandlerMethodArgumentResolver`

## 12.8 스프링 데이터 JPA가 사용하는 구현체
- `SimpleJpaRepository` : 스프링 데이터 JPA가 제공하는 공통 인터페이스
- 내부 코드
    - `@Repository` : JPA 예외를 스프링이 추상화한 예외로 변환
    - `@Transactional` : 트랜잭션 적용, 서비스 계층에서 트랜잭션을 시작하지 않으면 리포지토리에서 트랜잭션 시작
      서비스 계층에서 트랜잭션 시작했으면 리포지토리에서 해당 트랜잭션을 전파받아서 그대로 사용
    - `@Transactional(readOnly=true)` : 읽기 전용, 플러시를 생략해서 성능 향상 가능
    - `save()` : 새로운 엔티티(객체일 때 null, 기본 타입일때 숫자 0)이면 저장하고, 이미 있는 엔티티면 병합(`merge`)

## 12.10 QueryDsl과 통합
- `QueryDslPredicateExcutor` 상속 : 편리하지만 기능에 한계가 있다.
- `QueryDslRepositorySupport` : 편리하게 QueryDsl의 다양한 기능을 사용할 수 있다.

📌 Q1. OSIV란 ? (560p)
2. SimpleJpaRepository와 JpaRepository와의 차이?(562p)
3. findOrders는 어느 파일? 명세로 검색하는 부분 잘 이해가 안간다. (571p)
4. PageRequest와 Pageable 차이? (561p)

### [0802] 578~598
# 13. 웹 애플리케이션과 영속성 관리
## 13.1 트랜잭션 범위의 영속성 컨텍스트
### 스프링 컨테이너의 기본 전략
- 스프링 컨테이너는 트랜잭션 범위의 영속성 컨텍스트 전략을 기본으로 사용한다.
- 트랜잭션의 범위와 영속성 컨텍스트의 생존 범위가 같다.
- 트랜잭션을 시작할 때(보통 서비스 계층, `@Transactional`) 영속성 컨텍스트를 생성하고 트랜잭션이 끝날 때 영속성 컨텍스트를 종료한다.
- 같은 트랜잭션 안에서는 항상 같은 영속성 컨텍스트에 접근한다.

- 스프링 트랜잭션 AOP는 대상 메서드를 호출하기 직전에 트랜잭션을 시작하고, 대상 메소드가 정상 종료되면 트랜잭션을 커밋하면서 종료한다.
    - 커밋하면 먼저 영속성 컨텍스트를 flush해서 db에 변경 내용을 반영한 후에 데이터베이스 트랜잭션을 커밋한다.
    - 예외가 발생하면 트랜잭션을 롤백하고 종료하는데 이때는 flush를 호출하지 않는다.

- 트랜잭션이 같으면 같은 영속성 컨텍스트를 사용한다.
- 트랜잭션이 다르면 다른 영속성 컨텍스트를 사용한다.
> 스프링 컨테이너는 스레드마다 각각 다른 트랜잭션을 할당한다. 멀티 스레드 환경에 안전하다.

## 13.2 준영속 상태와 지연 로딩
- 스프링이나 J2EE 컨테이너는 트랜잭션 범위의 영속성 컨텍스트 전략을 기본으로 사용한다.
- 트랜잭션은 보통 서비스 계층에서 시작하므로 서비스 계층이 끝나는 시점에 트랜잭션이 종료되면서 영속성 컨텍스트도 함께 종료된다.
    - 조회한 엔티티가 서비스와 리포지토리 계층에서는 영속 상태를 유지하지만, 컨트롤러나 뷰 같은 표현 계층에서는 준영속 상태가 된다.
    - 변경 감지와 지연 로딩이 동작하지 않는다. 특히 초기화되지 않은 프록시 객체의 초기화를 시도할 경우 `LazyInitializationException` 예외가 발생한다.

- 준영속 상태의 지연 로딩 문제를 해결하는 방법
    - **뷰가 필요한 엔티티를 미리 로딩해두는 방법**
        - 글로벌 Fetch 전략 수정 (FetchType 수정)
        - JPQL Fetch Join
        - 강제로 초기화
    - **OSIV를 사용해서 엔티티를 항상 영속 상태로 유지하는 방법**

### 1. 글로벌 Fetch 전략 수정
- 지연 로딩에서 즉시 로딩으로 변경한다.
- 단점 1: 사용하지 않는 엔티티를 로딩한다.
- 단점 2: N+1 문제가 발생한다.
> JPA가 JPQL을 분석해서 SQL을 생성할 때는 글로벌 페치 전략을 참고하지 않고 오직 JPQL 자체만 사용한다.

### 2. JPQL Fetch Join
- Fetch Join을 사용하면 SQL JOIN을 사용해서 Fetch Join 대상까지 함께 조회한다. 따라서 N+1 문제가 발생하지 않는다.
- 단점 : 프레젠테이션 계층이 알게 모르게 데이터 접근 계층을 침범한다.
> 화면에 필요한 엔티티를 데이터 접근 계층에서 조회하므로 의존관계가 생긴다.

### 3. 강제로 초기화
- 영속성 컨텍스트가 살아있을 때 프레젠테이션 계층이 필요한 엔티티를 강제로 초기화해서 반환하는 방법
- 프록시를 초기화하는 코드를 서비스 계층이 담당하면 뷰가 필요한 엔티티에 따라 서비스 계층의 로직을 변경해야 한다.
> 서비스 계층은 비즈니스 로직을 담당해야지 프레젠테이션 계층을 위한 일까지 하는 것은 좋지 않다.

### FACADE 계층 추가
- 뷰를 위한 프록시 초기화를 담당한다. Controller와 Service 사이에 위치한다.
- 서비스 계층과 프레젠테이션 계층 사이에 논리적인 의존성을 분리할 수 있다.
- `FACADE`에서 트랜잭션을 시작해야 한다.
- 단점: 중간에 계층이 하나 더 끼어든다. 단순히 서비스 계층을 호출만 하는 위임 코드가 상당히 많다.

## 13.3 OSIV(Open Session In View)
- 영속성 컨텍스트를 View까지 열어두어 영속성 컨텍스트가 살아있으면 엔티티는 영속 상태로 유지된다.
    - 뷰에서도 지연 로딩을 사용할 수 있다.
### 과거 OSIV : 요청 당 트랜잭션
- 클라이언트의 요청이 들어오자마자 서블릿 필터나 스프링 인터셉터에서 트랜잭션을 시작하고, 요청이 끝날 때 트랜잭션도 끝낸다.
- 영속성 컨텍스트가 처음부터 끝까지 살아있으므로 조회한 엔티티도 영속 상태를 유지한다.
- 뷰에서도 지연 로딩을 할 수 있다.
- 단점: Controller나 View 같은 프레젠테이션 계층이 엔티티를 변경할 수 있다.

- 프레젠테이션 계층에서 엔티티를 수정하지 못하게 막는 방법
    1. 엔티티를 읽기 전용 인터페이스로 제공
    2. 엔티티 Wrapping
    3. DTO만 반환

- 엔티티를 읽기 전용 인터페이스로 제공
    - getter만 제공하는 읽기 전용 인터페이스를 View에 제공한다.
- 엔티티 Wrapping
    - getter(읽기 전용 메서드)만 가지고 있는 엔티티를 감싼 객체를 만들고 프레젠테이션 계층에 반환한다.
- DTO만 반환

- 과거 OSIV인 요청 당 트랜잭션은 최근에는 거의 사용되지 않는다.
    - 최근에는 이런 문제를 보완해서 비즈니스 계층에서만 트랜잭션을 유지하는 방식의 OSIV를 사용한다.
    - 스프링 프레임워크가 제공하는 OSIV가 뒤에 나올 방식을 사용한다.

### 스프링 OSIV : 비즈니스 계층 트랜잭션
- `hibernate osiv 서블릿 필터`
- `hibernate osiv 스프링 인터셉터`
- `hibernate oeiv 서블릿 필터`
- `hibernate oeiv 스프링 인터셉터`

- 요청당 트랜잭션 방식의 OSIV는 프리젠테이션 계층에서 데이터를 변경할 수 있다는 문제가 있다.
- 스프링 프레임워크가 제공하는 OSIV는 비즈니스 계층에서 트랜잭션을 사용하는 OSIV이다.
    - OSIV를 사용하지만 트랜잭션은 비즈니스 계층에서만 사용한다.
    - 클라이언트의 요청이 들어오면 영속성 컨텍스트를 생성한다.
    - 서비스 계층에서 트랜잭션을 시작하면 생성해둔 영속성 컨텍스트에 트랜잭션을 시작한다.
    - 서비스 계층이 끝나면 트랜잭션을 커밋하면서 영속성 컨텍스트를 flush한다.
    - 트랜잭션만 종료하고 영속성 컨텍스트는 살려둔다.
    - 클라이언트 요청이 끝날 때 영속성 컨텍스트를 종료한다.

📌 1. J2SE 환경과 J2EE 컨테이너란? (578p)
2. 즉시 로딩 사용시 왜 left outer join을 안하고 하나하나 select문을 날릴까? 오직 jpql 자체만 사용해서 jpq가 sql을 만든다는 의미가 무엇일까? (587p)
3. 준영속 상태에서 지연로딩이 되지 않으므로 뷰에 보여질 데이터를 미리 로딩할 수 밖에 없는데, 그렇다면 의존 관계는 해결할 수 없는것일까? FACADE말고 해결 방법은 없을까? REST API에서도 여전히 해결 방법은 없을까? (593p)

### [0803] 600~620
### **트랜잭션 없이 읽기**
- 트랜잭션 없이 엔티티를 변경하고 영속성 컨텍스트를 flush하면 `TransactionRequiredException`이 발생한다.
- 영속성 컨텍스트는 트랜잭션 범위 안에서 엔티티를 조회하고 수정할 수 있다.
- 영속성 컨텍스트는 트랜잭션 범위 밖에서 엔티티를 조회만 할 수 있다. (=트랜잭션 없이 읽기)
  프록시를 초기화하는 지연 로딩도 조회 기능이므로 트랜잭션 없이 읽기가 가능하다.
> 스프링이 제공하는 OSIV를 사용하면 프리젠테이션 계층에서는 트랜잭션이 없으므로 엔티티를 수정할 수 없다. 조회는 가능하므로 지연 로딩은 가능하다.

**비즈니스 계층 트랜잭션 정리**
- **영속성 컨텍스트를 프리젠테이션 계층까지 유지**한다.
- 프리젠테이션 계층에는 트랜잭션이 없으므로 **엔티티를 수정할 수 없다.**
    - 영속성 컨텍스트의 엔티티가 수정되지만 이미 트랜잭션이 커밋되면서 flush된 이후 수정되었으므로 영속성 컨텍스트만 종료된다.(db 반영 X)
- 프리젠테이션 계층에는 트랜잭션이 없지만 **트랜잭션 없이 읽기를 사용해서 지연 로딩을 할 수 있다.**

### 스프링 OSIV 주의사항
- 스프링 OSIV를 사용하면 **프리젠테이션 계층에서 엔티티를 수정해도 수정 내용을 db에 반영하지 않는다.**
- 프리젠테이션 계층에서 **엔티티를 수정한 직후에 트랜잭션을 시작하는 서비스 계층을 호출**할 경우,  트랜잭션을 커밋한 후 영속성 컨텍스트가 flush 되므로 **변경 감지가 동작하며 db에 변경사항이 반영된다**.
  ***=> 트랜잭션이 있는 비즈니스 로직을 모두 호출하고나서 엔티티를 변경하자.***

> 스프링 OSIV는 요청이 시작되고 끝날때까지 영속성 컨텍스트를 유지하므로 한 영속성 컨텍스트를 여러 트랜잭션이 공유할 수 있어 이러한 문제가 발생한다.

### OSIV 정리
- 스프링 OSIV 특징
    - OSIV는 클라이언트의 요청이 들어왔을 때 영속성 컨텍스트를 생성해서 요청이 끝날때까지 같은 영속성 컨텍스트를 유지한다. 따라서 한번 조회한 엔티티는 요청이 끝날 때까지 영속 상태를 유지한다.
    - 엔티티 수정은 트랜잭션이 있는 계층에서만 동작한다. 트랜잭션이 없는 프리젠테이션 계층은 지연 로딩을 포함해서 조회만 할 수 있다.

- 스프링 OSIV 단점
    - OSIV를 적용하면 같은 영속성 컨텍스트를 여러 트랜잭션이 공유할 수 있다. 특히 트랜잭션 롤백을 주의해야한다.
    - 프레젠테이션 계층에서 엔티티 수정 후 비즈니스 로직 호출시 엔티티가 수정될 수 있다.
    - 프리젠테이션 계층에서 지연 로딩에 의한 sql이 실행된다. 따라서 성능 튜닝시에 확인해야할 부분이 넓다.

- `OSIV` vs `FACADE` vs `DTO`
    - 준영속 상태가 되기전에 프록시를 초기화하거나, OSIV를 사용하는 방법이 있다.
    - OSIV를 사용하면 화면 출력시 객체 그래프를 마음껏 탐색할 수 있지만 복잡한 화면 구성시 처음부터 jpql을 작성해서 dto로 조회하는 것이 효과적이다.
- OSIV는 같은 JVM을 벗어난 원격 상황에서는 사용할 수 없다.
    - 결국 클라이언트가 필요한 데이터를 모두 json으로 생성하여 반환해야 한다.

## 13.4 너무 엄격한 계층
- OSIV를 사용하기 전에는 프리젠테이션 계층에서 사용할 지연 로딩된 엔티티를 미리 초기화해야 했다. 초기화는 서비스 계층이나 FACADE 계층이 담당했다.
- 하지만 **OSIV를 사용하면 영속성 컨텍스트가 프리젠테이션 계층까지 살아있으므로 미리 초기화할 필요가 없다.** 따라서 단순한 엔티티 조회는 컨트롤러에서 리포지토리를 직접 호출해도 상관없다.

## 13.5 정리
- 스프링이나 J2EE 컨테이너 환경에서 JPA를 사용하면 **트랜잭션 범위의 영속성 컨텍스트 전략이 사용**된다.
    - 이 전략은 **트랜잭션 범위와 영속성 컨텍스트 생존 범위가 같다.**
- **같은 트랜잭션 안에서는 항상 같은 영속성 컨텍스트에 접근한다**.
- 단점으로는 프리젠테이션 계층에서 엔티티가 준영속 상태가 되므로 지연 로딩을 할 수 없다.
- 스프링 프레임워크가 제공하는 OSIV를 사용하면 프리젠테이션 계층에서 지연로딩을 하면서도 엔티티를 수정하지 않는다.

# 14. 컬렉션과 부가 기능
# 14.1 컬렉션
- `@OneToMany`, `@ManyToMany`를 이용해서 일대다나 다대다 관계를 매핑할 때
- `@ElementCollection`을 사용해서 값 타입을 하나 이상 보관할 때
### JPA와 컬렉션
- hibernate는 엔티티를 영속 상태로 만들 때 컬렉션 필드를 하이버네이트에서 준비한 컬렉션으로 감싸서 사용한다.
- **Collection, List -> PersistentBag**
    - 중복된 엔티티가 있는지 비교하지 않으므로 엔티티를 추가해도 지연 로딩된 컬렉션을 초기화하지 않는다.
- **Set -> PersistentSet**
    - 중복된 엔티티가 있는지 비교하므로 엔티티 추가시 지연 로딩된 컬렉션을 초기화한다.
- **List + @OrderColumn -> PersistentList**
    - `@OrderColumn `: 순서값을 저장해서 조회할 때 사용한다.
        - 다 테이블에서 매핑하므로 순서값을 알 수 없어 추가 sql문이 발생한다.
        - List 변경시 순서값도 변경해야하고, 중간에 값이 없으면 null이 저장되어 값 순회시 NPE가 발생할 수 있다.
- `@OrderBy` : 컬렉션을 정렬할 때 사용한다. 엔티티의 필드를 대상으로 한다.

# 14.2 컨버터
- 엔티티의 데이터를 변환해서 데이터베이스에 저장할 수 있다.

📌
Q1. osiv를 사용하지 않는 대안 중 dto를 사용하는 방법이 이해가 가지 않는다. dto 사용시 준영속이 되지 않나? (604p)
Q2. 스프링 프레임워크가 제공하는 osiv를 사용하면 컨트롤러에서 엔티티를 조회할 수 있다고 하는데 이게 좋은 방법일까? (606p)
Q3. 트랜잭션 범위의 영속성 컨텍스트 전략에서 프리젠테이션 계층에서 엔티티가 준영속 상태가 되어 지연로딩이 불가능한다고 한다. 만약 서비스에서 컨트롤러로 dto 전달시 사용할때에는 지연 로딩이 발생하지 않을까? (607p)
Q4. 지금은 스프링 OSIV를 사용할까 트랜잭션 범위의 영속성 컨텍스트를 주로 사용할까? (607p)
Q5. 컬렉션을 사용할 때 즉시 초기화해서 사용하는 것을 권장한다고 하는데 이해가 안간다.(612p)
Q6. Set는 원소 추가할때마다 컬렉션을 초기화하는가 ? (615p)

### [0804] 621~639
## 컨버터
- `@Converter `어노테이션 사용하고 AttrivuteConverter 인터페이스 구현
- 현재 타입과 변환할 타입 지정
- 클래스 레벨에도 적용 가능
  ` @Convert(converter=BooleanToYNConverter.class, attributeName="vip")`
### 글로벌 설정
- 모든 Boolean 타입에 컨버터를 적용하려면 @Converter(autoApply=true) 옵션 적용하기

# 14.3 리스너
- JPA의 리스너 기능을 사용하면 엔티티의 생명주기에 따른 이벤트를 처리할 수 있다.
-  `PostLoad` : 엔티티가 영속성 컨텍스트에 조회된 직후 또는 refresh 호출 후
- `PrePersist` : persist() 메서드 호출해서 엔티티를 영속성 컨텍스트에 관리하기 직전
- `PreUpdate` : flush나 commit 호출해서 엔티티를 데이터베이스에 수정하기 직전
- `PreRemove` : remove() 메서드 호출해서 엔티티를 영속성 컨텍스트에서 삭제하기 직전
- `PostPersist` : flush나 commit 호출해서 엔티티를 데이터베이스에 저장한 직후
- `PostUpdate`: flush나 commit 호출해서 엔티티를 데이터베이스에 수정한 직후
- `PostRemove` : flush나 commit 호출해서 엔티티를 데이터베이스에 삭제한 직후

## 이벤트 적용 위치
### 엔티티 직접 적용
@PrePersist, @PostLoad ...
엔티티에 이벤트가 발생할 때마다 어노테이션으로 지정한 메서드가 실행된다.
### 별도의 리스너 등록
- `@EntityListeners(DuckListener.class)`
- 리스너 클래스 메서드의 반환 타입은 void
### 기본 리스너 사용
- META-INF/orm.xml에 기본 리스너로 등록

### 이벤트 호출 순서
1. 기본 리스너
2. 부모 클래스 리스너
3. 리스너
4. 엔티티
- `ExcludeDefaultListeners`: 기본 리스너 무시
- `ExcludeSuperclassListeners` : 상위 클래스 이벤트 리스너 무시

# 14.4 엔티티 그래프
- 엔티티를 조회할 때 연관된 엔티티들을 함께 조회하려면 `FetchType.EAGER`로 선택하거나 JPQL에서 `fetch join`을 사용한다.
- 글로벌 fetch 옵션은 애플리케이션 전체에 영향을 주고 변경할 수 없다.
- 따라서 LAZY로 사용하고 연관된 엔티티를 함께 조회하려면 JPQL의 fetch join을 사용하자.
- 함께 조회할 엔티티에 따라 JPQL을 달리 써야하는 문제 => 엔티티 그래프 기능을 이용하자.

## 엔티티 그래프
- 엔티티 조회시점에 연관된 엔티티들을 함께 조회하는 기능
- 정적으로 정의하는 Named 엔티티 그래프와 동적으로 정의하는 엔티티 그래프가 있다.

### Named 엔티티 그래프
- `@NamedEntityGraph`로 정의한다.
- name: 엔티티 그래프 이름, attributeNodes: 함께 조회할 속성 선택

### em.find()에서 엔티티 그래프 사용
- 엔티티 그래프를 찾아 힌트의 값으로 사용하고 key는 `javax.persistence,fetchgraph`를 사용한다.

### subgraph
- Order -> OrderItem -> Item까지 함께 조회하려면 subgraph를 사용한다.
- `@NamedSubGraph`를 사용해서 서브 그래프를 정의한다.

### JPQL에서 엔티티 그래프 사용
- setHint로 지정하여 엔티티 그래프를 가져와 key를 `javax.persistence,fetchgraph`로 사용한다.
> `em.find()`에서 엔티티 그래프를 사용하면 hibernate는 필수 관계일때 내부 조인을 사용하지만, jpql에서는 항상 외부 조인을 사용한다. 내부 조인을 사용하려면 명시해주어야 한다.

### 동적 엔티티 그래프
- `createEntityGraph() `메서드를 사용하면 된다.

### 엔티티 그래프 정리
- ROOT에서 시작
- 영속성 컨텍스트에 이미 로딩된 엔티티는 엔티티 그래프가 적용되지 않는다.
- `fetchgraph`: 엔티티 그래프에 선택한 속성만 함께 조회, `loadgraph`: FetchType.EAGER로 설정된 연관관계도 함께 조회

## 정리
- JPA가 지원하는 컬렉션의 종류와 특징
- 컨버터: 엔티티의 데이터를 변환해서 데이터베이스에 저장
- 리스너: 엔티티에서 발생한 이벤트를 받아서 처리
- `fetch join`: 객체지향 쿼리를 사용하지만, 엔티티 그래프를 사용하면 원하는 객체 그래프 한번에 조회 가능

📌
Q1. 리스너 등록시 이벤트 호출 순서에서 기본 리스너란? 그냥 리스너와의 차이? (627p)
Q2. 엔티티 그래프 사용시 내부 조인을 명시하는 부분이 어디있는지? (634p)
Q3. 영속성 컨텍스트에 엔티티가 이미 로딩되었다면 엔티티 그래프가 적용되지 않는다고 하는데, 엔티티 그래프가 적용된다는 의미?


### [0805] 640~660
# 15. 고급 주제와 성능 최적화
## 15.1 예외 처리
### JPA 표준 예외 정리
- **트랜잭션 롤백을 표시하는 예외**
    - 심각한 예외이므로 복구해서는 안된다.
    - 강제로 커밋해도 트랜잭션이 커밋되지 않고 `RollbackException` 예외가 발생한다.
- **트랜잭션 롤백을 표시하지 않는 예외**
    - 심각한 예외가 아니다. 개발자가 커밋할지 롤백할지 선택하면 된다.
### 스프링 프레임워크의 JPA 예외 변환
- 서비스 계층에서 JPA 예외를 직접 사용하면 JPA에 의존하게 된다.
- 스프링 프레임워크는 데이터 접근 계층에 대한 예외를 추상화해서 개발자에게 제공한다.
### 스프링 프레임워크에 JPA 예외 변환기 사용
- JPA 예외를 스프링 프레임워크가 제공하는 추상화된 예외로 변경하려면 `PersistenceExceptionTranslationPostProcessor`를 스프링 빈으로 등록하면 된다.
- `@Repository`를 사용한 곳에 예외변환 AOP를 적용해서 JPA 예외를 스프링 프레임워크가 추상화한 예외로 변환해준다.
- 예외를 변환하고 싶지 않다면 `throws` 절에 그대로 반환할 JPA 예외나 JPA 예외의 부모 클래스를 직접 명시하면 된다.
### 트랜잭션 롤백시 주의사항
- 트랜잭션을 롤백하는 것은 데이터베이스의 반영 사항만 롤백하는 것이지 수정한 자바 객체까지 원상태로 복구해주지는 않는다. (객체는 수정된 상태로 영속성 컨텍스트에 남아있다.)
- 따라서 롤백된 영속성 컨텍스트를 그대로 사용하는 것보다 새로운 영속성 컨텍스트를 생성해서 사용하거나,  `EntityManager.clear()`를 호출해서 영속성 컨텍스트를 초기화한 다음에 사용해야한다.

- OSIV
    - **트랜잭션당 영속성 컨텍스트 전략** : 문제가 발생하면 트랜잭션을 롤백하면서 영속성 컨텍스트도 함께 종료하므로 문제가 발생하지 않는다.
    - **OSIV**: 여러 트랜잭션이 하나의 영속성 컨텍스트를 사용하므로 롤백 후 다른 트랜잭션이 영속성 컨텍스트를 사용할 수 있는 문제가 있다.
    - **스프링**은 트랜잭션 롤백시 영속성 컨텍스트를 초기화해서 잘못된 영속성 컨텍스트를 사용하는 문제를 예방한다.

# 15.2 엔티티 비교
- **1차 캐시**: 영속성 컨텍스트 내부에는 엔티티 인스턴스를 보관하기 위한 1차 캐시가 있다. 1차 캐시는 영속성 컨텍스트와 생명주기가 같다.
    - 영속성 컨텍스트를 통해 데이터를 저장하거나 조회하면 1차 캐시에 엔티티가 저장된다.
    - 변경 감지도 동작하고, 데이터베이스를 통하지 않고 데이터를 바로 조회할 수 있다.
    - **애플리케이션 수준의 반복 가능한 읽기**(항상 같은 엔티티 인스턴스 반환)을 제공한다.
### 영속성 컨텍스트가 같을 때 엔티티 비교
- 테스트에 `@Transactional`이 있을 때
- 같은 트랜잭션 범위에 있으면 같은 영속성 컨텍스트를 사용하므로 동일성(`\==`), 동등성(`equals()`), 데이터베이스 동등성(`@Id`)을 모두 만족한다.
### 영속성 컨텍스트가 다를때 엔티티 비교
- 테스트에 `@Transactional`이 없고 서비스와 레포지토리에 `@Transactional`이 있을때
- 서비스에서 조회한 엔티티와 레포지토리에서 조회한 엔티티는 다른 영속성 컨텍스트에서 각각 조회한 엔티티이므로 서로 다른 인스턴스를 반환한다.
- 동일성(`\==`) 비교에 실패한다.
- 다른 영속성 컨텍스트에서 조회하더라도 같은 엔티티이므로 데이터베이스 동등성 비교(db 식별자) 나 동등성 비교(비즈니스 키)를 통해 같게 판단하도록 하자.
    - 비즈니스 키는 보통 중복되지 않고 거의 변하지 않는 데이터베이스 기본키 후보들이 좋다. db 기본키처럼 딱딱하게 정하지 않아도 되고, 가끔 변해도 괜찮다.
> 동일성 비교는 같은 영속성 컨텍스트의 관리를 받는 영속 상태의 엔티티에만 적용할 수 있다. 그렇지 않을 때는 `비즈니스 키`를 사용한 동등성 비교를 해야 한다.

## 15.3 프록시 심화 주제
- 프록시는 원본 엔티티를 상속받아 만들어진다.
- 클라이언트는 엔티티가 프록시인지 원본 엔티티인지 구분하지 않고 사용할 수 있다.

### 영속성 컨텍스트와 프록시
- 영속성 컨텍스트는 자신이 관리하는 영속 엔티티의 동일성을 보장한다.
- **프록시로 조회한 엔티티의 동일성도 보장한다.**
    - 프록시로 먼저 조회한 후 엔티티를 조회하면 처음 조회된 프록시를 반환한다.
    - 엔티티를 조회한 후 프록시를 조회하면 엔티티를 반환한다.

### 프록시 타입 비교
- 프록시와 원본 엔티티를 비교할 때는 ==이 아니라 `instanceof`를 사용해야 한다. (프록시는 원본 엔티티를 상속받는 자식이기 때문이다.)
### 프록시 동등성 비교
- 프록시 타입 비교는 `\==` 비교 대신에 `instanceof`를 사용해야 한다.
- 프록시의 멤버변수에 직접 접근하면 안되고, 대신에 접근자 메서드(`getter`)를 사용해야한다.

📌
Q1. 트랜잭션 롤백을 표시한다는 의미는 무엇일까? (640p)
2. 645p에서 스프링은 트랜잭션 롤백시 영속성 컨텍스트를 초기화한다고 하는데, 여기서 스프링은 스프링 OSIV를 의미하는 것일까 스프링 프레임워크를 말하는 것일까?
3. 영속성 컨텍스트가 다르면 새로 엔티티 인스턴스를 만들어 저장하기 때문에 다른 것일까? (652p)
4. 영속성 컨텍스트는 프록시로 먼저 조회한 후 엔티티를 조회하면 프록시를 반환한다고 하는데, 이 프록시는 엔티티에서 조회한 모든 필드의 값이 포함된 초기화된 프록시일까? (654p)

# 📌 질문 & 대답 정리

## 2024.08.01 질문

### 1. OSIV란 무엇인가? (560p)
**영속성 컨텍스트를 뷰 렌더링(프레젠테이션 계층)까지 유지하는 기술**이다.
프레젠테이션 계층에서도 지연 로딩을 가능하게 한다.
하지만 데이터베이스 커넥션을 오래 유지해야 하므로 성능 이슈가 발생할 수 있다.

### 2. SimpleJpaRepository와 JpaRepository의 차이는? (562p)
- `JpaRepository`: 인터페이스. SimpleJpaRepository를 기본 구현체로 사용
    - 기본적인 CRUD 연산과 페이징, 정렬 기능을 정의
- `SimpleJpaRepository`: 실제 구현체
> 개발자는 보통 JpaRepository를 상속받아 사용하며, 내부적으로 SimpleJpaRepository가 동작한다.
```java
public interface UserRepository extends JpaRepository<User, Long> {
}
```
- 스프링 데이터 JPA가 이 인터페이스의 구현체를 자동으로 생성한다.
- 이 자동 생성된 구현체는 내부적으로 `SimpleJpaRepository`를 사용한다.
- `SimpleJpaRepository`는 `JpaRepository` 인터페이스의 기본 구현을 제공한다.
> 인터페이스 기반 프록시 생성: 개발자는 인터페이스만 정의하고, 스프링이 런타임에 해당 인터페이스의 구현체를 동적으로 생성하여 주입하는 방식

### 3. findOrders는 어느 파일에 있는가? 명세로 검색하는 부분이 이해하기 어렵다. (571p)
서비스 파일에 정의
-
### 4. PageRequest와 Pageable의 차이는? (561p)
- `Pageable`: 인터페이스. PageRequest가 이를 구현한다.
- `PageRequest`: 구체적인 구현체
    - 실제 페이지 번호, 페이지 크기, 정렬 정보 등
> 메서드에서 Pageable 타입의 파라미터를 받으면, 실제로는 PageRequest 객체가 전달된다.
```java
@GetMapping("/users")
public Page<User> getUsers(Pageable pageable) {
}
```

```
요청: /users?page=0&size=20&sort=name,desc
```
스프링은 이 정보를 바탕으로 `PageRequest` 객체를 생성하고, 이를 `pageable` 파라미터로 전달한다.

> 개발자가 컨트롤러나 서비스 메서드에서 Pageable 타입의 파라미터를 선언하면, 스프링은 자동으로 PageRequest 객체를 생성하여 이 파라미터에 주입한다.

## 2024.08.02 질문

### 1. J2SE 환경과 J2EE 컨테이너란 무엇인가? (578p)
- J2SE: 기본적인 Java 애플리케이션 개발을 위한 환경
- J2EE 컨테이너: 대규모 분산 엔터프라이즈 애플리케이션을 위한 환경
    - 트랜잭션 관리, 보안, 네이밍, 리소스 풀링 등의 서비스를 제공

### 2. 즉시 로딩 사용 시 왜 left outer join을 하지 않고 개별 select문을 실행하는가? "오직 JPQL 자체만 사용해서 JPA가 SQL을 만든다"는 의미는 무엇인가? (587p)
- JPA는 엔티티에 설정된 즉시 로딩(EAGER) 전략을 JPQL 쿼리 생성 시 고려하지 않는다.
  즉시 로딩(EAGER) 전략:
    - 엔티티를 조회할 때 연관된 엔티티도 함께 조회하는 전략
    - JPA는 `LEFT OUTER JOIN`을 사용
- JPQL은 **작성된 쿼리 자체만을 기반으로 SQL을 생성**한다.
    - JPQL은 객체지향 쿼리 언어로, **엔티티 객체를 대상으로 쿼리를 작성**한다.
    - JPQL을 SQL로 변환할 때, JPA는 엔티티에 설정된 즉시 로딩 전략을 고려하지 않는다.

- JPQL에서 명시적으로 **조인을 지정하지 않으면**, JPA는 **기본 엔티티만 조회**하는 SQL을 생성한다.
    - 그 후 **즉시 로딩으로 설정된 연관 엔티티를 위해 추가적인 SELECT 쿼리를 실행**한다.
        - 메인 쿼리 1번 + 연관 엔티티를 위한 N번의 쿼리 = **N+1 문제**
        - 예: 10개의 주문을 조회하고, 각 주문의 고객 정보가 즉시 로딩이라면,
          1번의 주문 조회 쿼리 + 10번의 고객 조회 쿼리 = 11번의 쿼리 실행

> JPQL에서 명시적으로 `join fetch`를 사용하면, JPA는 한 번의 쿼리로 연관 엔티티를 함께 조회할 수 있다.

   ```sql
   select o from Order o join fetch o.customer
   ```

### 3. 준영속 상태에서 지연 로딩이 되지 않아 뷰에 보여질 데이터를 미리 로딩해야 하는데, 이 경우 의존 관계 문제를 해결할 수 없는 것인가? FACADE 외에 다른 해결 방법은 없는가? REST API에서도 해결 방법이 없는가? (593p)
`DTO` 변환, `FACADE` 패턴, `OSIV` 사용 등으로 해결이 가능하다.
REST API에서는 주로 `DTO`를 사용한다.

## 2024.08.03 질문

### 1. OSIV를 사용하지 않는 대안 중 DTO를 사용하는 방법이 이해가 가지 않는다. DTO 사용 시 준영속 상태가 되지 않는가? (604p)
`DTO`(Data Transfer Object): 엔티티의 데이터를 담는 순수한 자바 객체
- 서비스 계층에서 **필요한 데이터만 DTO에 담아 반환**한다.
    - DTO는 영속성 컨텍스트와 무관하므로 준영속 상태를 걱정할 필요가 없다.
- 뷰에 필요한 데이터를 미리 로딩하여 DTO에 담기 때문에 지연 로딩 문제를 방지할 수 있다.

### 2. 스프링 프레임워크가 제공하는 OSIV를 사용하면 컨트롤러에서 엔티티를 조회할 수 있다고 하는데, 이것이 좋은 방법인가? (606p)
OSIV를 사용하면 컨트롤러에서도 엔티티를 조회할 수 있지만, 장단점이 있다.
장점
- 편리한 개발 (지연 로딩 가능)
- 뷰에서 필요한 데이터를 유연하게 접근 가능
  단점
- 데이터베이스 커넥션을 오래 물고 있어 성능 이슈 가능
- 비즈니스 로직과 프레젠테이션 로직의 경계가 모호해질 수 있음

### 3. 트랜잭션 범위의 영속성 컨텍스트 전략에서 프레젠테이션 계층에서 엔티티가 준영속 상태가 되어 지연 로딩이 불가능하다고 한다. 서비스에서 컨트롤러로 DTO 전달 시 사용할 때는 지연 로딩이 발생하지 않는가? (607p)
서비스에서 DTO로 변환 시 **필요한 데이터를 모두 로딩하여 DTO**에 담는다.
- 이후 컨트롤러나 뷰에서는 이 DTO를 사용하므로 **추가적인 지연 로딩이 발생하지 않는다**.
- DTO는 영속성 컨텍스트와 무관하므로 **준영속 상태 문제가 없다**.

### 4. 현재는 스프링 OSIV를 사용하는가, 아니면 트랜잭션 범위의 영속성 컨텍스트를 주로 사용하는가? (607p)
- 대규모, 고성능이 필요한 애플리케이션: `트랜잭션` 범위의 영속성 컨텍스트 + `DTO` 사용
- 중소규모, 빠른 개발이 필요한 애플리케이션: `OSIV` 사용
> 상황에 따라 다르다.

### 5. 컬렉션을 사용할 때 즉시 초기화해서 사용하는 것을 권장한다고 하는데 이해가 되지 않는다. (612p)
지연 로딩으로 인한 성능 이슈 방지를 위해서이다.
- **지연 로딩**은 연관된 엔티티나 컬렉션을 실제로 사용할 때까지 데이터베이스에서 로딩하지 않는다.
    - 이로 인해 불필요한 데이터 로딩을 방지하여 초기 로딩 시간을 줄일 수 있다.
- **컬렉션에 접근할 때마다 별도의 쿼리가 실행**된다.
    - 예를 들어, 100개의 주문을 조회하고 각 주문의 주문 항목(컬렉션)에 접근한다면:
        * 주문 조회 쿼리 1번
        * 각 주문의 주문 항목 조회 쿼리 100번
    - 이것이 **N+1** 문제 발생 (1개의 주문 쿼리 + N개의 주문 항목 쿼리)

3. 즉시 초기화를 하면 **필요한 데이터를 한 번**에 가져올 수 있다.
    - 예를 들어, JOIN FETCH를 사용하면
      ```sql
      SELECT o FROM Order o JOIN FETCH o.orderItems
      ```

성능을 비교하면,
- 지연 로딩: 많은 수의 작은 쿼리 실행 (N+1)
- 즉시 초기화: 하나의 큰 쿼리 실행
> 대부분의 경우, 하나의 큰 쿼리가 여러 개의 작은 쿼리보다 성능이 좋다.

### 6. Set은 원소 추가할 때마다 컬렉션을 초기화하는가? (615p)
Set은 원소 추가 시 마다 전체를 초기화하지는 않는다.
하지만 중복 여부를 확인하기 위해 기존 요소들과 비교 연산을 수행하고, 이 과정에서 아직 초기화되지 않은 프록시 객체가 있다면 초기화가 발생할 수 있다.

## 2024.08.04 질문

### 1. 리스너 등록 시 이벤트 호출 순서에서 '기본 리스너'란 무엇인가? 일반 리스너와의 차이는? (627p)
- **기본 리스너**: 모든 엔티티에 자동 적용
    - persistence.xml 파일이나 orm.xml 파일에 정의
- **일반 리스너**: 특정 엔티티에만 적용
    - `@EntityListeners` 어노테이션을 사용하여 엔티티 클래스에 직접 정의

### 2. 엔티티 그래프 사용 시 내부 조인을 명시하는 부분이 어디에 있는가? (634p)
JPQL에서 명시적으로 지정해야 한다.
```java
String jpql = "select o from Order o join o.member m";
List<Order> orders = em.createQuery(jpql, Order.class)
    .setHint("javax.persistence.fetchgraph", em.getEntityGraph("Order.withMember"))
    .getResultList();
```

### 3. 영속성 컨텍스트에 엔티티가 이미 로딩되었다면 엔티티 그래프가 적용되지 않는다고 하는데, '엔티티 그래프가 적용된다'는 것의 의미는 무엇인가?
엔티티 그래프에 지정된 연관 엔티티들이 함께 로딩된다는 것을 의미한다.
> 영속성 컨텍스트에 이미 로딩된 엔티티가 있다면, JPA는 데이터베이스에서 다시 조회하지 않고 이미 있는 엔티티를 재사용한다.

## 2024.08.05 질문

### 1. '트랜잭션 롤백을 표시한다'는 의미는 무엇인가? (640p)
해당 예외 발생 시 트랜잭션을 반드시 롤백해야 함을 의미한다.

JPA는 예외를 크게 두 종류로 구분한다.
- 롤백을 표시하는 예외
    - 주로 심각한 시스템 예외나 데이터 무결성을 해치는 예외
    - JPA 구현체는 내부적으로 트랜잭션에 롤백 마크를 표시한다.
    - 이후 트랜잭션을 커밋하려고 해도 롤백이 수행된다.
    - ex) `EntityNotFoundException`
- 그렇지 않은 예외
    - 커밋 or 롤백 선택 가능하다.

### 2. 645p에서 스프링이 트랜잭션 롤백 시 영속성 컨텍스트를 초기화한다고 하는데, 여기서 '스프링'은 스프링 OSIV를 의미하는 것인가, 아니면 스프링 프레임워크를 말하는 것인가?
여기서 '스프링'은 스프링 프레임워크를 의미한다. (스프링의 트랜잭션 관리 기능)
- 스프링 프레임워크는 트랜잭션 관리를 위한 추상화 계층을 제공하는데, **OSIV 사용 여부와 관계없이 작동**한다.
- 트랜잭션이 **롤백**될 때, **스프링은 영속성 컨텍스트를 초기화**하여 잘못된 상태의 엔티티가 다음 요청에 영향을 미치지 않도록 한다.

### 3. 영속성 컨텍스트가 다르면 새로 엔티티 인스턴스를 만들어 저장하기 때문에 다른 것인가? (652p)
영속성 컨텍스트가 다르면 동일한 데이터베이스 row에 대해서도 서로 다른 엔티티 인스턴스가 생성된다.
- 각 영속성 컨텍스트는 자신만의 1차 캐시를 가지고 있다.
- 엔티티를 조회할 때, 해당 영속성 컨텍스트의 **1차 캐시에 엔티티가 없으면 새로운 인스턴스를 생성**한다.
- 따라서 서로 다른 영속성 컨텍스트에서 같은 데이터베이스 row를 조회하면, 각각 새로운 엔티티 인스턴스가 생성된다.

> 동일성(=\=) 비교에서는 false가 반환되지만, 동등성(equals) 비교에서는 true가 반환될 수 있다.
> (equals()도 적절히 구현해야 한다.)

### 4. 영속성 컨텍스트는 프록시로 먼저 조회한 후 엔티티를 조회하면 프록시를 반환한다고 하는데, 이 프록시는 엔티티에서 조회한 모든 필드의 값이 포함된 초기화된 프록시인가? (654p)
초기화되지 않은 상태의 프록시를 반환한다. (JPA는 동일성을 보장하기 위해 프록시를 그대로 반환한다.)
- 이 프록시는 처음 생성될 때와 마찬가지로 초기화되지 않은 상태
  프록시의 메서드가 호출될 때(getter 등) 실제 엔티티 데이터를 로딩하는 초기화 과정이 발생한다.

> JPA의 지연 로딩 원칙을 유지하면서도 영속성 컨텍스트의 동일성을 보장하는 방식

